<html><head><base href=".">
<title>Texas Powerball Generator</title>
 <style>
.lottery-header {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 20px;
}

.lottery-logo {
    width: 100%;
    max-width: 300px;
    height: auto;
}

.lottery-header h1 {
    flex: 1;
    text-align: center;
    cursor: default;
}

body {
  font-family: Arial, sans-serif;
  background: linear-gradient(135deg, #f0f8ff, #e6e6fa);
  display: flex;
  justify-content: center;
  align-items: flex-start;   /* keep the container pinned to the top */
  min-height: 100vh;         /* optional—only ensures a minimum height */
  margin: 0;
  padding: 20px;
}

.lottery-container {
    background: white;
    padding: 2rem;
    border-radius: 15px;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    text-align: center;
    width: 95%;
    max-width: 1200px;
}

.controls {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.control-label {
    font-weight: bold;
    color: #333;
}

.prediction-methods {
    margin: 20px 0;
}

.radio-group {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 10px;
}

.radio-group label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    position: relative;
}

.tooltip {
    visibility: hidden;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    width: 200px;
    z-index: 1000;
    text-align: center;
    opacity: 0;
    transition: opacity 0.3s;
}

.tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
}

.radio-group label:hover .tooltip {
    visibility: visible;
    opacity: 1;
}

.export-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
}

.draw-container {
    margin: 15px 0;
    border-bottom: 1px solid #eee;
    padding: 5px;
}

.probability {
    color: #666;
    font-style: italic;
    margin: 10px 0;
    font-size: 14px;
    padding: 5px;
    background: #f5f5f5;
    border-radius: 5px;
    display: inline-block;
}

.draw-date {
    font-weight: bold;
    color: #333;
    margin: 10px 0;
}

.ball-container {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 10px 0;
    height: 200px;
    align-items: flex-start;
}

.ball {
    width: 200px;
    height: 200px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 51px;
    font-weight: bold;
    color: #000000;
    background: radial-gradient(circle at 30% 30%, 
        rgba(255,255,255,0.8) 0%, 
        rgba(255,255,255,0.3) 20%, 
        rgba(79,167,255,0.6) 50%, 
        #147AFF 90%);
    position: relative;
    top: -400px;
    box-shadow: 
        inset -10px -10px 20px rgba(0,0,0,0.3),
        0 4px 8px rgba(0,0,0,0.2);
    scale: 0.5;
    opacity: 0;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.ball:hover {
    transform: scale(1.1) translateY(-5px);
    box-shadow: 
        inset -10px -10px 20px rgba(0,0,0,0.3),
        0 8px 16px rgba(0,0,0,0.3);
    z-index: 1;
}

.powerball {
    background: radial-gradient(circle at 30% 30%, 
        rgba(255,255,255,0.8) 0%, 
        rgba(255,255,255,0.3) 20%, 
        rgba(255,75,43,0.6) 50%, 
        #ff416c 90%);
}

button, input {
    padding: 10px 20px;
    border-radius: 25px;
    font-size: 16px;
}

button {
    background: linear-gradient(145deg, #2ecc71, #27ae60);
    border: none;
    color: white;
    cursor: pointer;
    transition: transform 0.2s ease;
}

button:disabled {
    background: linear-gradient(145deg, #cccccc, #999999);
    cursor: not-allowed;
    opacity: 0.5;
    transform: none;
}

button:hover {
    transform: scale(1.05);
}

button:disabled:hover {
    transform: none;
}

.input {
    border: 1px solid #ccc;
    text-align: center;
}

.export-btn {
    background: linear-gradient(145deg, #3498db, #2980b9);
    padding: 10px 20px;
    border-radius: 25px;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s ease;
}

.export-btn:hover {
    transform: scale(1.05);
}

.export-btn:disabled {
    background: linear-gradient(145deg, #cccccc, #999999);
    cursor: not-allowed;
    transform: none;
}

.export-btn:disabled:hover {
    transform: none;
}

.automation-controls {
    display: none;
    gap: 20px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 10px;
}

.progress-container {
    display: none;
    width: 100%;
    margin: 20px 0;
    text-align: center;
}

.progress-bar {
    width: 100%;
    max-width: 500px;
    height: 20px;
    background-color: #f0f0f0;
    border-radius: 10px;
    overflow: hidden;
    margin: 10px auto;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(145deg, #2ecc71, #27ae60);
    width: 0%;
    transition: width 0.3s ease;
}

.progress-text {
    color: #666;
    font-size: 14px;
    margin-top: 5px;
}
#trainingProgressWrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
}

#trainingProgressLabel {
    font-size: 1.2em;
    margin-bottom: 10px;
}

#trainingProgress {
    width: 80%;
    height: 20px;
}
@keyframes dropAndBounce {
    0% { 
        transform: scale(0.5);
        top: -400px;
        opacity: 0;
    }
    40% {
        transform: scale(1.2);
        top: -80px;
        opacity: 1;
    }
    60% { 
        transform: scale(1);
        top: 40px;
        opacity: 1;
    }
    75% { 
        transform: scale(1.1);
        top: -20px;
        opacity: 1;
    }
    85% { 
        transform: scale(1);
        top: 20px;
        opacity: 1;
    }
    95% { 
        transform: scale(1.05);
        top: -10px;
        opacity: 1;
    }
    100% { 
        transform: scale(1);
        top: 0;
        opacity: 1;
    }
}

@media print {
    body {
        background: white;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
    }
    
    .lottery-container {
        box-shadow: none;
        width: 100%;
        padding: 0;
    }
    
    .controls, .export-controls {
        display: none;
    }
    
    .draw-container {
        break-inside: avoid;
        page-break-inside: avoid;
    }
    
    .draw-container:nth-child(5n) {
        page-break-after: always;
    }
    
    .ball {
        print-color-adjust: exact;
        -webkit-print-color-adjust: exact;
    }

    .print-condensed .lottery-container {
        transform: scale(0.80) !important;
        transform-origin: top center;
        margin: 0 !important;
    }
    
    .print-condensed .draw-container {
        margin: 5px 0;
        padding: 2px;
    }
    
    .print-condensed .ball-container {
        margin: 5px 0;
    }
    
    .print-condensed .draw-date {
        margin: 5px 0;
    }
}

.history-table-container {
    margin: 40px 0;
    padding: 20px;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.history-table-title {
    text-align: center;
    color: #333;
    font-size: 24px;
    margin-bottom: 20px;
}

.drawing-history {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

.drawing-history tr.all-numbers-match {
    background-color: rgba(0, 0, 255, 0.1) !important;
}

.drawing-history tr.all-numbers-match:hover {
    background-color: rgba(0, 0, 255, 0.2) !important;
}

.drawing-history .number-cell {
    display: inline-block; 
    margin-right: 5px;
}

.drawing-history td.powerball-number {
    text-align: left;
}

.drawing-history th, 
.drawing-history td {
    text-align: left !important;
    padding: 12px !important;
    vertical-align: top;
}

.duplicate-number {
    color: green;
    font-weight: bold;
}

.drawing-history tr.highest-probability {
    background-color: rgba(255, 255, 0, 0.2) !important;
}

.drawing-history tr.highest-probability:hover {
    background-color: rgba(255, 255, 0, 0.3) !important;
}

@media print {
    .drawing-history th,
    .drawing-history td {
        text-align: left !important;
        padding: 12px !important;
    }
    .powerball-number {
        color: #ff0000 !important;
        font-weight: bold !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
    }
}
.drawing-history .powerball-number {
    color: #ff0000 !important;
    font-weight: bold !important;
}

@media print {
    .powerball-number {
        color: #ff0000 !important;
        font-weight: bold !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
    }
    .duplicate-number {
        color: #008000 !important;
        font-weight: bold !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
    }
}

.drawing-history tr {
    position: relative;
}

.drawing-history tr.all-numbers-match:hover::after,
.drawing-history tr.highest-probability:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
}
  
/* vNext Fix: make manual-entry "ball" inputs comfortably fit 2 digits and remove number spinners */
.number-input {
  width: 88px !important;
  height: 88px !important;
  font-size: 26px !important;
  padding: 0 !important;
  line-height: 1 !important;
}
.number-input::-webkit-outer-spin-button,
.number-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.number-input[type=number] {
  -moz-appearance: textfield;
}

</style>
</head>
<body>
<div class="lottery-container">
    <div class="lottery-header">
        <img src="https://www.texaslottery.com/export/sites/lottery/Images/powerball-banner.png" alt="Texas Powerball Logo - Red and white powerball lottery logo" class="lottery-logo" width="200" height="67">
        <h1>Texas Powerball Generator</h1>
    </div>
    
    <div class="controls">
        
        <div class="control-group">
            <label for="startDate" class="control-label">Draw Date</label>
            <input type="date" id="startDate" min="2024-01-19">
        </div>
        <div class="control-group">
            <label for="drawCount" class="control-label">Number of Draws</label>
            <input type="number" id="drawCount" min="1" max="100" value="1" placeholder="Number of draws">
        </div>
       
	<!-- Load Historical Data Button -->   
	<div class="control-group">
   	<div style="display:flex; align-items:center; gap:10px; justify-content:center;">
        <button id="loadDataBtn" class="export-btn"
            style="background: linear-gradient(145deg, #e67e22, #d35400);">
            Load Historical Data
        </button>
        <span id="autoSaveLight" title="Auto-save status" style="
            width:14px;height:14px;border-radius:50%;
            display:inline-block;
            background:#cc0000;
            box-shadow:0 0 0 2px rgba(0,0,0,0.08);
        "></span>
    </div>
<div class="control-group">
		<button onclick="showManualEntryForm()" class="export-btn" 
			id="manualEntryBtn"
			style="background: linear-gradient(145deg, #9b59b6, #8e44ad);" disabled>
			Enter Recent Powerball Numbers
		</button>
	</div>

    <!-- Bypass Historical Data Checkbox -->
    <div style="margin-top: 10px;">
        <label>
            <input type="checkbox" id="bypassHistoricalData" /> Bypass Historical Data
        </label>
    </div>
</div>

</div>
    <div class="control-group prediction-methods">
        <label class="control-label">Prediction Method:</label>
        <div class="radio-group">
            <label>
                <input type="radio" name="predictionMethod" value="exponential" checked>
                Exponential
                <span class="tooltip">Uses exponential distribution to generate numbers, considering historical patterns with decay over time. May take a few moments to process.</span>
            </label>
            <label>
                <input type="radio" name="predictionMethod" value="frequency">
                Frequency
                <span class="tooltip">Analyzes the frequency of numbers in past draws to make predictions based on most common occurrences.</span>
            </label>
            <label>
                <input type="radio" name="predictionMethod" value="lstm">
                LSTM
                <span class="tooltip">Uses Long Short-Term Memory neural networks to learn complex patterns from historical data. Requires initial training.</span>
            </label>
            <label>
                <input type="radio" name="predictionMethod" value="monteCarlo">
                Monte Carlo
                <span class="tooltip">Simulates multiple random draws using probability distributions from historical data to make predictions.</span>
            </label>
            <label>
                <input type="radio" name="predictionMethod" value="markov">
                Markov
                <span class="tooltip">Uses Weighted Markov Chain Model to predict numbers based on transition probabilities from historical patterns.</span>
            </label>
            <label>
                <input type="radio" name="predictionMethod" value="everything">
                Everything
                <span class="tooltip">Advanced ensemble method combining multiple prediction models with weighted calculations based on historical performance. Most accurate but requires longer processing time.</span>
            </label>
        </div>
    </div>
 <div class="control-group">
 <button onclick="generateDraws()" id="generateNumbersBtn">Generate Powerball Numbers</button>
    </div>
   <div class="progress-container" id="progressContainer" style="display: none;">
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-text" id="progressText">Generating predictions...</div>
</div>

<!-- Training Progress Bar with Label -->
<div id="trainingProgressWrapper" style="display: none;">
    <label for="trainingProgress" id="trainingProgressLabel">Training Model...0%</label>
    <progress id="trainingProgress" value="0" max="100"></progress>
</div>
    
    <div id="drawsContainer"></div>

    <div class="history-table-container">
        <h2 class="history-table-title">Drawing History</h2>
        <table class="drawing-history">
            <thead>
                <tr>
                    <th data-sort="model">Model Type</th>
                    <th data-sort="date">Draw Date &#x25bc;</th>
                    <th data-sort="numbers">Numbers</th>
                    <th data-sort="powerball">Powerball</th>
                    <th data-sort="probability">Probability (%)</th>
                </tr>
            </thead>
            <tbody id="historyTableBody">
            </tbody>
        </table>
    </div>

    <div class="duplicates-table-container">
    <h2 class="history-table-title">Top Duplicates</h2>
    <table class="drawing-history styled-duplicates-table">
        <thead>
            <tr>
                <th style="width: 50%;">Numbers</th>
                <th style="width: 15%;">Powerball</th>
                <th style="width: 20%;">Probability</th>
                <th style="width: 15%;">Frequency</th>
            </tr>
        </thead>
        <tbody id="duplicatesTableBody">
        </tbody>
    </table>
</div>

<style>
    .duplicates-table-container {
        margin: 40px 0;
        padding: 20px;
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .history-table-title {
        text-align: center;
        color: #333;
        font-size: 24px;
        margin-bottom: 20px;
    }

    .drawing-history {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
    }

    .drawing-history th, .drawing-history td {
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid #ddd;
    }

    .drawing-history th {
        background-color: #f4f4f4;
        font-weight: bold;
    }

    .drawing-history td {
        font-size: 16px;
    }

    .powerball-highlight {
        font-weight: bold;
        color: red;
    }

    .duplicate-number {
        font-weight: bold;
        color: #007bff;
    }
</style>


<!-- Generate Slip Section -->
<div id="controls-container" style="
    display: none;
    border: 2px solid #ccc;
    border-radius: 10px;
    padding: 20px;
    width: 70%;
    margin: 20px auto;
    text-align: center;
    background-color: #f9f9f9;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">

    <!-- Heading -->
    <h2 style="margin-bottom: 20px; font-size: 20px; color: #333; font-weight: bold;">
        Generate Powerball Play Slip
    </h2>


    <!-- Load PDF File Section -->
    <div style="margin-bottom: 20px;">
        <button id="load-file-btn" disabled style="
            background-color: #007bff;
            color: white;
            font-size: 16px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: not-allowed;
            transition: background-color 0.3s;">
            Load Powerball Template File (PDF)
        </button>
        <input type="file" id="pdf-upload" accept=".pdf" style="display: none;" />
    </div>

    <!-- Number of Games Selector -->
    <div style="margin-bottom: 20px;">
        <label for="num-games" style="font-size: 16px; font-weight: bold;">Number of Games:</label>
        <select id="num-games" style="
            font-size: 16px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-left: 5px;">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select>
    </div>

    <!-- Checkboxes -->
    <div style="margin-bottom: 15px;">
  <label>
    <input type="checkbox" id="quick-pick-game-4" /> Quick Pick for Game 4
  </label>
  <label style="margin-left: 10px;">
    <input type="checkbox" id="quick-pick-game-5" /> Quick Pick for Game 5
  </label>
  <label>
    <input type="checkbox" id="use-duplicates-game5" /> Use Duplicates for Game 5
  </label>
  <!-- ✦ NEW: family #s checkbox -->
  <label style="margin-left: 10px;">
    <input type="checkbox" id="use-family-numbers" /> Use Family #s
  </label>
</div>
<div>
  <label style="margin-left: 10px;">
    <input type="checkbox" id="powerplay-checkbox" /> PowerPlay
  </label>
</div>

 
<!-- Radio Buttons -->
    <div style="margin-bottom: 15px;">
        <label>
            <input type="radio" name="payment-option" value="30Year" id="payment-30year" /> 30 Year Annual Payment Option
        </label>
        <label style="margin-left: 10px;">
            <input type="radio" name="payment-option" value="CashValue" id="payment-cashvalue" checked /> Cash Value Option
        </label>
    </div>


    <!-- Generate Slip Button -->
    <button id="generate-slip" disabled style="
        background-color: green;
        color: white;
        font-size: 16px;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: not-allowed;
        transition: background-color 0.3s;">
        Generate Powerball Play Slip
    </button>
</div>

<div class="export-controls">
        <button class="export-btn" onclick="exportToFile()" disabled>Save to File</button>
        <button class="export-btn" onclick="exportToEmail()" disabled>Send via Email</button>
        <button class="export-btn" onclick="printResults()" disabled>Print Results</button>
        <button class="export-btn" onclick="printDrawingHistory()" disabled>Print Drawing History</button>
    </div>
</div>

<div id="manualEntryModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 2rem; border-radius: 15px; box-shadow: 0 0 20px rgba(000,0,0.2); z-index: 1000;">
    <h3 style="margin-top: 0;">Enter Winning Numbers</h3>
    <div id="numberEntry" style="display: flex; gap: 15px; margin: 20px 0; justify-content: center;">
        <!-- 5 regular balls and 1 Powerball textboxes will be inserted here by JavaScript -->
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="submitManualEntry()" style="margin-right: 10px;">Submit</button>
        <button onclick="hideManualEntryForm()">Cancel</button>
    </div>
</div>

<!-- tfjs is loaded on-demand for performance -->
<script src="script.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>

<script>
let model = null;
let automationActive = false;
let completedDraws = 0;
let totalAutomatedDraws = 0;
function getNextDrawingDate(date = new Date()) {
  const drawingDays = [1, 3, 6];
  let nextDate = new Date(date);
  nextDate.setHours(0, 0, 0, 0);
  while (!drawingDays.includes(nextDate.getDay())) {
    nextDate.setDate(nextDate.getDate() + 1);
  }
  return nextDate;
}

function getNextBlankDrawingDateFrom(historyDateSet, fromDate) {
  // Returns the next scheduled draw date (Mon/Wed/Sat) on or after fromDate that is NOT in historyDateSet.
  // historyDateSet should contain YYYY-MM-DD strings.
  let d = getNextDrawingDate(fromDate);
  // Safety guard
  for (let i = 0; i < 400; i++) {
    const ds = d.toISOString().split('T')[0];
    if (!historyDateSet || !historyDateSet.has(ds)) return d;
    d.setDate(d.getDate() + 1);
    d = getNextDrawingDate(d);
  }
  return getNextDrawingDate(fromDate);
}

function computeNextBlankDrawDateISO(fromDate = new Date()) {
  // Find the next scheduled draw date that isn't already in historicalData.
  const historySet = new Set(
    Array.isArray(window.historicalData)
      ? window.historicalData
          .map(r => r?.date)
          .filter(Boolean)
      : []
  );

  // Base the search off the most recent historical date when possible,
  // otherwise fall back to the provided date/today.
  let base = fromDate instanceof Date && !isNaN(fromDate) ? fromDate : new Date();
  if (historySet.size > 0) {
    const latest = Array.from(historySet).sort().pop();
    if (latest) base = new Date(latest);
  }
  const nextBlank = getNextBlankDrawingDateFrom(historySet, base);
  return nextBlank ? nextBlank.toISOString().split('T')[0] : '';
}

function updateWinningDateSelectorToNextBlank() {
  const dateInput = document.getElementById('drawDate');
  if (!dateInput) return;

  const nextBlank = computeNextBlankDrawDateISO();
  if (nextBlank) {
    const label = formatDate(nextBlank);
    let opt = Array.from(dateInput.options).find(o => o.value === nextBlank);
    if (!opt) {
      opt = new Option(label, nextBlank);
      dateInput.appendChild(opt);
    } else {
      opt.textContent = label;
    }
    const idx = Array.from(dateInput.options).findIndex(o => o.value === nextBlank);
    dateInput.selectedIndex = idx >= 0 ? idx : 0;
    dateInput.value = nextBlank;
  } else if (dateInput.options.length > 0) {
    dateInput.selectedIndex = 0;
    dateInput.value = dateInput.options[0].value;
  } else {
    const meBtn = document.getElementById('manualEntryBtn');
    if (meBtn) {
      meBtn.disabled = true;
      meBtn.setAttribute('disabled', '');
      meBtn.style.opacity = '0.5';
    }
  }
}

function updateLoadButtonWithLastDate(dateStr) {
  if (!dateStr) return;
  const loadDataBtn = document.getElementById('loadDataBtn');
  const lastDrawDateText = document.getElementById('lastDrawDateText');
  const formatted = new Date(dateStr).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  if (loadDataBtn) {
    loadDataBtn.innerHTML = `Load Historical Data<br><small style="font-size:12px;font-weight:bold;color:green;">Last Historical Draw Date: ${formatted}</small>`;
  }
  if (lastDrawDateText) {
    lastDrawDateText.textContent = `Last Historical Draw Date: ${formatted}`;
  }
}

function updateLoadButtonWithLastDrawDate() {
  if (!Array.isArray(window.historicalData) || window.historicalData.length === 0) return;
  const sorted = window.historicalData.slice().sort((a, b) => new Date(b.date) - new Date(a.date));
  const last = sorted[0];
  if (last?.date) updateLoadButtonWithLastDate(last.date);
}

function isDrawingDay(date) {
  const day = date.getDay();
  return day === 1 || day === 3 || day === 6;
}
function getNextValidDrawDate(startDate, drawIndex) {
  let date = new Date(startDate);
  let drawsFound = 0;
  while (drawsFound < drawIndex) {
    date.setDate(date.getDate() + 1);
    if (isDrawingDay(date)) {
      drawsFound++;
    }
  }
  return date;
}
function seededRandom(seed, offset = 0) {
  if (isNaN(seed)) {
    return Math.random();
  }
  const x = Math.sin(seed + offset) * 10000;
  return Math.abs(x - Math.floor(x));
}
function normalizeMap(map) {
  const total = Array.from(map.values()).reduce((sum, value) => sum + value, 0);
  if (total === 0) return;
  map.forEach((value, key) => map.set(key, value / total));
}
function adjustPredictionWithPreviousResults(predicted) {
  let {
    numbers,
    powerball
  } = predicted;
  previousPredictions.forEach(previous => {
    const commonNumbers = numbers.filter(num => previous.numbers.includes(num));
    const mismatchNumbers = numbers.filter(num => !previous.numbers.includes(num));
    if (commonNumbers.length >= 3 && mismatchNumbers.length > 0) {
      numbers = numbers.map(num => {
        return commonNumbers.includes(num) ? num : mismatchNumbers[0];
      });
    }
  });
  const powerballFrequencyMap = new Map();
  historicalData.forEach((draw, idx) => {
    const weight = Math.exp(-0.01 * (historicalData.length - idx));
    powerballFrequencyMap.set(draw.special, (powerballFrequencyMap.get(draw.special) || 0) + weight);
  });
  normalizeMap(powerballFrequencyMap);
  const randomValue = seededRandom(new Date().getTime(), predicted.powerball);
  let cumulativeWeight = 0;
  for (const [num, weight] of powerballFrequencyMap.entries()) {
    cumulativeWeight += weight;
    if (randomValue <= cumulativeWeight) {
      powerball = num;
      break;
    }
  }
  return {
    numbers,
    powerball
  };
}
function predictNumbersExponential(date, drawIndex = 0) {
  try {
    const alpha = 0.5;
    const beta = 0.3;
    let level = 0;
    let trend = 0;
    historicalData.forEach(draw => {
      const drawAvg = draw.numbers.reduce((sum, num) => sum + num, 0) / draw.numbers.length;
      const newLevel = alpha * drawAvg + (1 - alpha) * (level + trend);
      trend = beta * (newLevel - level) + (1 - beta) * trend;
      level = newLevel;
    });
    const predictedNumbers = new Set();
    while (predictedNumbers.size < 5) {
      const prediction = Math.round(level + trend + Math.random() * 10 * (drawIndex + 1));
      if (prediction >= 1 && prediction <= 69) {
        predictedNumbers.add(prediction);
      }
    }
    const powerball = (Math.ceil(Math.random() * 26) + drawIndex) % 26 + 1;
    const predictions = {
      numbers: Array.from(predictedNumbers).sort((a, b) => a - b),
      powerball,
      method: "Exponential"
    };
    predictions.probability = calculateProbability(predictions.numbers, predictions.powerball, "Exponential");
    return predictions;
  } catch (error) {
    console.error("Exponential prediction error:", error);
    return null;
  }
}
function predictNumbersFrequency(date, drawIndex = 0) {
  try {
    const frequencyMap = new Map();
    const powerballMap = new Map();
    const decayFactor = 0.95; // Exponential decay for weighting

    historicalData.forEach((draw, index) => {
      const ageWeight = Math.pow(decayFactor, historicalData.length - index - 1);

      draw.numbers.forEach(num => {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + ageWeight);
      });

      powerballMap.set(draw.special, (powerballMap.get(draw.special) || 0) + ageWeight);
    });

    const selectNumbers = (map, count) => {
      const entries = Array.from(map.entries());
      let candidates = new Set();
      let attempt = 0;

      while(candidates.size < count && attempt < 100) {
        const remainingWeight = entries.reduce((sum, [num, weight]) => 
          candidates.has(num) ? sum : sum + weight, 0);

        if(remainingWeight <= 0) break; // Prevent infinite loop

        const rand = Math.random() * remainingWeight;
        let cumulative = 0;

        for(const [num, weight] of entries) {
          if(candidates.has(num)) continue;
          cumulative += weight;
          if(rand <= cumulative) {
            candidates.add(num);
            break;
          }
        }
        attempt++;
      }
      return Array.from(candidates).slice(0, count);
    };

    let selectedNumbers = [];
    for(let i=0; i<1000 && selectedNumbers.length<5; i++) {
      selectedNumbers = Array.from(new Set([
        ...selectedNumbers,
        ...selectNumbers(frequencyMap, 5 - selectedNumbers.length)
      ]));
    }

    if(selectedNumbers.length < 5) {
      const remaining = Array.from(frequencyMap.keys())
        .filter(n => !selectedNumbers.includes(n))
        .sort(() => Math.random() - 0.5)
        .slice(0, 5 - selectedNumbers.length);
      selectedNumbers = [...selectedNumbers, ...remaining];
    }

    const pbEntries = Array.from(powerballMap.entries());
    const pbTotal = pbEntries.reduce((sum, [_, w]) => sum + w, 0);
    const pbRand = Math.random() * pbTotal;
    let pbCumulative = 0;
    let powerball = 1;

    for(const [num, weight] of pbEntries) {
      pbCumulative += weight;
      if(pbRand <= pbCumulative) {
        powerball = num;
        break;
      }
    }

    powerball = Math.min(Math.max(powerball, 1), 26);

    return {
      numbers: selectedNumbers
        .map(n => Math.min(Math.max(n, 1), 69))
        .sort((a, b) => a - b),
      powerball,
      method: "Frequency"
    };
  } catch (error) {
    console.error("Frequency prediction error:", error);
    return {
      numbers: Array.from({length:5}, ()=> Math.floor(Math.random()*69)+1).filter((v,i,a)=>a.indexOf(v)===i).slice(0,5).sort((a,b)=>a-b),
      powerball: Math.floor(Math.random()*26)+1,
      method: "Frequency (Error Fallback)"
    };
  }
}
async function predictNumbersMonteCarlo(date, drawIndex) {
  try {
    const simulations = 500;
    const frequencyMap = new Map();
    const powerballMap = new Map();
    const progressBar = document.getElementById("progressBar");
    if (progressBar) progressBar.style.display = "block";
    for (let i = 0; i < simulations; i++) {
      const numbers = new Set();
      while (numbers.size < 5) {
        numbers.add(Math.ceil(Math.random() * 69));
      }
      const powerball = Math.ceil(Math.random() * 26);
      numbers.forEach(num => frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1));
      powerballMap.set(powerball, (powerballMap.get(powerball) || 0) + 1);
      if (progressBar) {
        progressBar.value = (i + 1) / simulations * 100;
      }
    }
    if (progressBar) progressBar.style.display = "none";
    const selectTop = (map, count) => Array.from(map.entries()).sort((a, b) => b[1] - a[1]).slice(0, count).map(entry => entry[0]);
    const selectedNumbers = selectTop(frequencyMap, 5);
    const powerball = selectTop(powerballMap, 1)[0];
    return {
      numbers: selectedNumbers.sort((a, b) => a - b),
      powerball,
      method: "Monte Carlo"
    };
  } catch (error) {
    console.error("Monte Carlo prediction error:", error);
    return null;
  }
}
async function predictNumbersEverything(date, drawIndex) {
  try {
    const progressBar = document.getElementById("progressBar");
    if (progressBar) {
      progressBar.style.display = "block";
      progressBar.value = 0;
    } else {
      console.warn("Progress bar element not found. Skipping progress updates.");
    }
    const results = await Promise.allSettled([(async () => {
      if (progressBar) progressBar.value = 25;
      return predictNumbersExponential(date, drawIndex);
    })(), (async () => {
      if (progressBar) progressBar.value = 50;
      return predictNumbersFrequency(date, drawIndex);
    })(), (async () => {
      if (progressBar) progressBar.value = 75;
      return predictNumbersMonteCarlo(date, drawIndex);
    })()]);
    const [exponential, frequency, monteCarlo] = results.map(result => {
      if (result.status === "fulfilled" && result.value) {
        return result.value;
      } else {
        console.error(`Error in model: ${result.reason}`);
        alert(`Fallback to Frequency: Error in ${result.reason ? result.reason : "Unknown Error"}`);
        return null;
      }
    });
    if (!exponential || !monteCarlo) {
      console.warn("Falling back to Frequency model due to errors in other models.");
      if (progressBar) progressBar.style.display = "none";
      return frequency;
    }
    const numberSets = [{
      numbers: exponential.numbers,
      weight: 1.2
    }, {
      numbers: frequency.numbers,
      weight: 1.0
    }, {
      numbers: monteCarlo.numbers,
      weight: 1.1
    }];
    const weightedNumbers = new Map();
    numberSets.forEach(({
      numbers,
      weight
    }) => {
      numbers.forEach(num => {
        weightedNumbers.set(num, (weightedNumbers.get(num) || 0) + weight);
      });
    });
    const allNumbers = Array.from(weightedNumbers.entries()).sort((a, b) => b[1] - a[1]).slice(0, 5).map(entry => entry[0]);
    const powerballCandidates = [exponential.powerball, frequency.powerball, monteCarlo.powerball];
    const powerball = Math.round(powerballCandidates.reduce((a, b) => a + b, 0) / powerballCandidates.length);
    if (progressBar) progressBar.style.display = "none";
    return {
      numbers: allNumbers.sort((a, b) => a - b),
      powerball,
      method: "Everything"
    };
  } catch (error) {
    console.error("Everything prediction error:", error);
    alert("Critical error in Everything prediction: " + error.message);
    const progressBar = document.getElementById("progressBar");
    if (progressBar) progressBar.style.display = "none";
    return null;
  }
}
async function predictNumbersLSTM(sequence, drawIndex) {
  try {
    if (!model || !model.isTrained) {
      model = await trainModel(historicalData);
    }
    // Validate sequence shape to avoid ragged tensors / offset errors
    if (!Array.isArray(sequence) || sequence.length !== LSTM_SEQUENCE_LEN) {
      throw new Error("Invalid LSTM sequence length");
    }
    for (const d of sequence) {
      if (!Array.isArray(d?.numbers) || d.numbers.length !== 5 || !Number.isFinite(d.special)) {
        throw new Error("Invalid draw in LSTM sequence");
      }
    }
    const formattedSequence = sequence.map(draw => [...draw.numbers, draw.special]);
    const input = tf.tensor3d([formattedSequence]);
    const prediction = await model.predict(input).array();
    const predictedValues = prediction[0];
    const uniqueNumbers = new Set();
    const numberProbabilities = new Map();
    for (let i = 1; i <= 69; i++) {
      const randomFactor = Math.random() * 0.2 - 0.1;
      numberProbabilities.set(i, predictedValues[i % 5] + randomFactor);
    }
    const sortedNumbers = Array.from(numberProbabilities.entries()).sort((a, b) => b[1] - a[1]).map(entry => entry[0]);
    let index = 0;
    while (uniqueNumbers.size < 5 && index < sortedNumbers.length) {
      const num = sortedNumbers[index];
      if (drawIndex === 0) {
        uniqueNumbers.add(num);
      } else {
        const isRecentlyUsed = document.querySelectorAll('.draw-container').length > 0 && Array.from(document.querySelectorAll('.ball:not(.powerball)')).some(ball => parseInt(ball.textContent) === num);
        if (!isRecentlyUsed) {
          uniqueNumbers.add(num);
        }
      }
      index++;
      if (index >= sortedNumbers.length && uniqueNumbers.size < 5) {
        index = 0;
        numberProbabilities.clear();
        for (let i = 1; i <= 69; i++) {
          const randomFactor = Math.random() * 0.2 - 0.1;
          numberProbabilities.set(i, predictedValues[i % 5] + randomFactor);
        }
        sortedNumbers.length = 0;
        sortedNumbers.push(...Array.from(numberProbabilities.entries()).sort((a, b) => b[1] - a[1]).map(entry => entry[0]));
      }
    }
    const powerballProb = new Map();
    for (let i = 1; i <= 26; i++) {
      const randomFactor = Math.random() * 0.2 - 0.1;
      powerballProb.set(i, predictedValues[5] + randomFactor);
    }
    const sortedPowerballs = Array.from(powerballProb.entries()).sort((a, b) => b[1] - a[1]).map(entry => entry[0]);
    let powerball = sortedPowerballs[0];
    if (drawIndex > 0) {
      const usedPowerballs = Array.from(document.querySelectorAll('.ball.powerball')).map(ball => parseInt(ball.textContent));
      powerball = sortedPowerballs.find(num => !usedPowerballs.includes(num)) || powerball;
    }
    return {
      numbers: Array.from(uniqueNumbers).sort((a, b) => a - b),
      powerball,
      method: "LSTM"
    };
  } catch (error) {
    console.error('LSTM prediction error:', error);
    throw error;
  }
}

function calculateProbability(numbers, powerball, method) {
  try {
    const weights = {
      historicalFrequency: 0.3,
      recentPatterns: 0.25,
      methodAccuracy: 0.2,
      numberDistribution: 0.15,
      correlationFactor: 0.1
    };
    const historicalFrequencyScore = calculateHistoricalFrequencyScore(numbers, powerball);
    const recentPatternsScore = calculateRecentPatternsScore(numbers, powerball);
    const methodAccuracyScore = calculateMethodAccuracyScore(method);
    const numberDistributionScore = calculateNumberDistributionScore(numbers);
    const correlationScore = calculateCorrelationScore(numbers);
    const totalProbability = (historicalFrequencyScore * weights.historicalFrequency + recentPatternsScore * weights.recentPatterns + methodAccuracyScore * weights.methodAccuracy + numberDistributionScore * weights.numberDistribution + correlationScore * weights.correlationFactor) * 100;
    return Math.min(Math.max(totalProbability.toFixed(2), 0), 100);
  } catch (error) {
    console.error('Error calculating probability:', error);
    return 50.00;
  }
}
function calculateHistoricalFrequencyScore(numbers, powerball) {
  const decayFactor = 0.95;
  const frequencyMap = new Map();
  historicalData.forEach((draw, index) => {
    const weight = Math.pow(decayFactor, historicalData.length - index - 1);
    draw.numbers.forEach(num => {
      frequencyMap.set(num, (frequencyMap.get(num) || 0) + weight);
    });
    frequencyMap.set(`pb_${draw.special}`, (frequencyMap.get(`pb_${draw.special}`) || 0) + weight);
  });
  let score = numbers.reduce((acc, num) => {
    const freq = frequencyMap.get(num) || 0;
    const prior = freq / historicalData.length;
    const likelihood = 1 / 69;
    const posterior = prior * likelihood / (prior * likelihood + (1 - prior) * (1 - likelihood));
    return acc + posterior;
  }, 0) / numbers.length;
  const pbFreq = frequencyMap.get(`pb_${powerball}`) || 0;
  const pbPrior = pbFreq / historicalData.length;
  const pbLikelihood = 1 / 26;
  const pbPosterior = pbPrior * pbLikelihood / (pbPrior * pbLikelihood + (1 - pbPrior) * (1 - pbLikelihood));
  return (score + pbPosterior) / 2;
}
function calculateRecentPatternsScore(numbers, powerball) {
  const windowSize = 10;
  const recentDraws = historicalData.slice(-windowSize);
  let patternScore = 0;
  recentDraws.forEach((draw, index) => {
    const recency = (index + 1) / windowSize;
    const matchCount = numbers.filter(num => draw.numbers.includes(num)).length;
    const pbMatch = draw.special === powerball ? 1 : 0;
    patternScore += (matchCount / 5 + pbMatch) * recency;
  });
  return patternScore / windowSize;
}
function calculateMethodAccuracyScore(method) {
  const methodAccuracy = {
    'Exponential': 0.85,
    'Frequency': 0.80,
    'LSTM': 0.90,
    'Monte Carlo': 0.82,
    'Markov': 0.83,
    'Everything': 0.88
  };
  return methodAccuracy[method] || 0.80;
}
function calculateNumberDistributionScore(numbers) {
  const mean = 35;
  const stdDev = 20;
  const distributionScore = numbers.reduce((score, num) => {
    const zScore = Math.abs(num - mean) / stdDev;
    return score + 1 / (1 + Math.exp(zScore - 2));
  }, 0) / numbers.length;
  return distributionScore;
}
function calculateCorrelationScore(numbers) {
  let correlationScore = 0;
  const ranges = [numbers.filter(n => n <= 23).length, numbers.filter(n => n > 23 && n <= 46).length, numbers.filter(n => n > 46).length];
  const rangeBalance = 1 - Math.max(...ranges) / 5;
  let consecutiveCount = 0;
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] - numbers[i - 1] === 1) consecutiveCount++;
  }
  const consecutiveBalance = 1 - consecutiveCount / 4;
  correlationScore = (rangeBalance + consecutiveBalance) / 2;
  return correlationScore;
}
async function generateDraws() {
    const elements = {
        container: document.getElementById('drawsContainer'),
        progress: {
            container: document.getElementById('progressContainer'),
            fill: document.getElementById('progressFill'),
            text: document.getElementById('progressText')
        },
        training: {
            wrapper: document.getElementById('trainingProgressWrapper'),
            bar: document.getElementById('trainingProgress'),
            label: document.getElementById('trainingProgressLabel')
        },
        exportButtons: document.querySelectorAll('.export-btn'),
        generateBtn: document.getElementById('generateNumbersBtn')
    };

    const nextFrame = () => new Promise(r => requestAnimationFrame(() => r()));
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // Reset UI
    elements.container.innerHTML = '';
    elements.progress.fill.style.width = '0%';
    elements.progress.text.textContent = '';
    elements.progress.container.style.display = 'none';
    elements.exportButtons.forEach(btn => btn.disabled = true);

    // Lock generate button while running
    if (elements.generateBtn) elements.generateBtn.disabled = true;

    const selectedMethod = document.querySelector('input[name="predictionMethod"]:checked')?.value || 'frequency';
    const selectedDateElement = document.getElementById('startDate');
    const drawCountElement = document.getElementById('drawCount');
    const selectedDate = new Date(selectedDateElement.value);
    const drawCount = Math.min(5, parseInt(drawCountElement.value, 10));

    if (isNaN(drawCount) || drawCount <= 0 || isNaN(selectedDate.getTime())) {
        alert("Please enter valid date and draw count values.");
        if (elements.generateBtn) elements.generateBtn.disabled = false;
        return;
    }

    let completedDraws = 0;
    let startDrawDate = getNextDrawingDate(selectedDate);
    let generatedGames = [];

    // ---------------------------
    // STAGE 1 — LSTM TRAINING (separate, completes BEFORE draws)
    // ---------------------------
    try {
        const bypass = document.getElementById("bypassHistoricalData")?.checked;

        if (!bypass && selectedMethod === 'lstm') {
            // Ensure TFJS + model are ready BEFORE any draws start
            elements.training.wrapper.style.display = 'flex';
            elements.training.bar.value = 0;
            elements.training.label.textContent = 'Training Model...0%';

            // Let the browser paint the training UI before heavy work
            await nextFrame();

            // Load TFJS on-demand (already implemented in vNext patch)
            await ensureTFJSLoaded();
            await nextFrame();

            // Train (guarded so it only happens once)
            await trainModel(window.historicalData);
            // trainModel hides the wrapper in finally; ensure it's hidden even if it didn't
            elements.training.wrapper.style.display = 'none';

            // User awareness (success) — non-blocking
            showSuccessPopup('LSTM Model is Ready');
            await sleep(200); // small yield so the toast paints before the next stage
        }

        // ---------------------------
        // STAGE 2 — DRAWS + ANIMATION (only begins AFTER training completes)
        // ---------------------------
        elements.progress.container.style.display = 'block';

        for (let i = 0; i < drawCount; i++) {
            const drawDate = getNextValidDrawDate(startDrawDate, i);

            let result;
            if (document.getElementById("bypassHistoricalData").checked) {
                // Random numbers (no history)
                const randomNumbers = [];
                for (let j = 0; j < 5; j++) randomNumbers.push(Math.floor(Math.random() * 69) + 1);
                const randomPowerball = Math.floor(Math.random() * 26) + 1;
                result = { numbers: randomNumbers, powerball: randomPowerball, method: "Random (No Historical Data)" };
            } else {
                result = await hybridPrediction(drawDate, i);
            }

            if (!result || !result.numbers || !Array.isArray(result.numbers)) {
                console.error("Invalid prediction result:", result);
                throw new Error("Failed to generate valid prediction (Numbers missing or incorrect format)");
            }

            const { numbers, powerball, method } = result;
            const sortedNumbers = [...numbers].sort((a, b) => a - b);
            const probability = calculateProbability(sortedNumbers, powerball, method);

            // Store result with probability for history table consistency
            result = { ...result, numbers: sortedNumbers, powerball, method, probability };

            generatedGames.push(result);

            const drawDiv = document.createElement('div');
            drawDiv.className = 'draw-container';
            drawDiv.innerHTML = `
                <div class="draw-date">${formatDate(drawDate)}</div>
                <div class="ball-container">
                    ${sortedNumbers.map(num => `<div class="ball">${num}</div>`).join('')}
                    <div class="ball powerball">${powerball}</div>
                </div>
                <div class="probability">Probability: ${probability}%</div>
                <div class="prediction-method">Method: ${method}</div>
            `;
            elements.container.appendChild(drawDiv);
            animateBalls(drawDiv);

            addToDrawingHistory(result, drawDate);

            completedDraws++;
            const progress = (completedDraws / drawCount) * 100;
            elements.progress.fill.style.width = `${progress}%`;
            elements.progress.text.textContent = `Generated Draw ${completedDraws} of ${drawCount}`;

            // yield so UI stays responsive
            await sleep(300);
            await nextFrame();
        }

        const editFormButton = document.createElement("button");
        editFormButton.textContent = "Edit All Games in Form";
        editFormButton.classList.add("export-btn");
        editFormButton.onclick = () => sendNumbersToForm(generatedGames);
        elements.container.appendChild(editFormButton);

    } catch (error) {
        alert(`Error generating predictions: ${error.message}`);
        console.error("Generation error:", error);
    } finally {
        elements.progress.container.style.display = 'none';
        elements.training.wrapper.style.display = 'none';

        // Re-enable exports (if any)
        elements.exportButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
        });

        // Unlock generate button
        if (elements.generateBtn) elements.generateBtn.disabled = false;

        setTimeout(() => {
            updateHistoryTable();
            checkAndNotifyForDrawing();
        }, 2000);
    }
}
function sendNumbersToForm(games) {
    const params = new URLSearchParams();

    games.forEach((game, index) => {
        params.append(`game${index + 1}_numbers`, game.numbers.join(","));
        params.append(`game${index + 1}_powerball`, game.powerball);
    });

    window.open(`Powerball_Form_Edit_1.html?${params.toString()}`, "_blank");
}

function checkAndNotifyForDrawing() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const nextDrawDate = getNextDrawingDate();
    nextDrawDate.setHours(0, 0, 0, 0);

    if (today.getTime() === nextDrawDate.getTime()) {
        const historyTableBody = document.getElementById('historyTableBody');

        const checkCompletion = setInterval(() => {
            const rows = Array.from(historyTableBody.querySelectorAll('tr'));
            if (rows.length > 0) {
                const drawingData = rows.map(row => ({
                    numbers: row.cells[2]?.textContent.split(',').map(num => parseInt(num.trim(), 10)),
                    powerball: parseInt(row.cells[3]?.textContent.trim(), 10),
                    probability: parseFloat(row.cells[4]?.textContent.trim().replace('%', ''))
                }));

                const highestProbabilityEntry = drawingData.reduce((max, entry) => 
                    (entry.probability > (max?.probability || 0) ? entry : max), null);

                if (highestProbabilityEntry) {
                    const formattedNumbers = highestProbabilityEntry.numbers.map(n => n.toString().padStart(2, '0')).join(', ');
                    const formattedPowerball = highestProbabilityEntry.powerball.toString().padStart(2, '0');

                    alert(`The next Powerball drawing is today! Go immediately to purchase your tickets.\n\n` + 
                          `Numbers with the greatest probability: [${formattedNumbers}] | Powerball: ${formattedPowerball}`);
                    clearInterval(checkCompletion);
                }
            }
        }, 500); 
    }
}
function formatDate(date) {
  return new Date(date).toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}
function animateBalls(container) {
  const balls = container.querySelectorAll('.ball');
  balls.forEach((ball, index) => {
    setTimeout(() => {
      ball.style.animation = 'dropAndBounce 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
    }, index * 200);
  });
}
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}
function printDrawingHistory() {
  if (drawingHistory.length === 0) {
    alert("No drawing history available to print.");
    return;
  }
  const printWindow = window.open('', '_blank');
  let tableHTML = `
        <html>
        <head>
            <title>Texas Powerball Drawing History</title>
            <style>
                body { 
                    font-family: Arial, sans-serif;
                    padding: 20px;
                    -webkit-print-color-adjust: exact !important;
                    print-color-adjust: exact !important;
                }
                h1 { 
                    text-align: center;
                    color: #333;
                    margin-bottom: 30px;
                }
                table { 
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                    page-break-inside: auto;
                }
                tr { 
                    page-break-inside: avoid;
                    page-break-after: auto;
                }
                thead {
                    display: table-header-group;
                }
                th, td { 
                    border: 1px solid #ddd;
                    padding: 12px 8px;
                    text-align: center;
                }
                th { 
                    background-color: #f5f5f5;
                    font-weight: bold;
                }
                .powerball-number {
                    color: #ff0000 !important;
                    font-weight: bold;
                }
                .duplicate-number {
                    color: #008000 !important;
                    font-weight: bold;
                }
                .highest-probability {
                    background-color: rgba(255, 255, 0, 0.2) !important;
                }
                .all-numbers-match {
                    background-color: rgba(0, 0, 255, 0.1) !important;
                }
                footer {
                    text-align: center;
                    margin-top: 30px;
                    font-size: 14px;
                    color: #666;
                }
                @media print {
                    body {
                        -webkit-print-color-adjust: exact !important;
                        print-color-adjust: exact !important;
                    }
                    .powerball-number {
                        color: #ff0000 !important;
                        font-weight: bold !important;
                    }
                    .duplicate-number {
                        color: #008000 !important;
                        font-weight: bold !important;
                    }
                    .highest-probability {
                        background-color: rgba(255, 255, 0, 0.2) !important;
                    }
                    .all-numbers-match {
                        background-color: rgba(0, 0, 255, 0.1) !important;
                        -webkit-print-color-adjust: exact !important;
                        print-color-adjust: exact !important;
                    }
                }
            </style>
        </head>
        <body>
            <h1>Texas Powerball Drawing History</h1>
            <table>
                <thead>
                    <tr>
                        <th>Model Type</th>
                        <th>Draw Date</th>
                        <th>Numbers</th>
                        <th>Powerball</th>
                        <th>Probability (%)</th>
                    </tr>
                </thead>
                <tbody>`;
 const sortedHistory = [...drawingHistory].sort((a, b) => new Date(a.drawDate) - new Date(b.drawDate));

  const numberFrequency = new Map();
  sortedHistory.forEach(entry => {
    entry.numbers.forEach(num => {
      numberFrequency.set(num, (numberFrequency.get(num) || 0) + 1);
    });
  });
  const maxProbability = Math.max(...sortedHistory.map(entry => parseFloat(entry.probability)));
  sortedHistory.forEach(entry => {
    const row = document.createElement('tr');
    if (parseFloat(entry.probability) === maxProbability) {
      row.classList.add('highest-probability');
    }
    const formattedDate = new Date(entry.drawDate).toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    const formattedNumbers = entry.numbers.map(num => {
      const isDuplicate = numberFrequency.get(num) > 1;
      return `<span class="number-cell${isDuplicate ? ' duplicate-number' : ''}">${num.toString().padStart(2, ' ')}</span>`;
    }).join(', ');
    row.innerHTML = `
        <td>${entry.method}</td>
        <td>${formattedDate}</td>
        <td>${formattedNumbers}</td>
        <td class="powerball-number">${entry.powerball.toString().padStart(2, ' ')}</td>
        <td>${entry.probability}%</td>
    `;
    const duplicatesInRow = entry.numbers.filter(num => numberFrequency.get(num) > 1).length;
    if (duplicatesInRow === 5) {
      row.classList.add('all-numbers-match');
    }
    tableHTML += row.outerHTML;
  });
  tableHTML += `
              </tbody>
          </table>
          <footer>
              Generated on ${new Date().toLocaleDateString("en-US", {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric'
  })}
          </footer>
      </body>
      </html>`;
  printWindow.document.write(tableHTML);
  printWindow.document.close();
  printWindow.onload = function () {
    printWindow.print();
    printWindow.close();
  };
}
function printResults() {
  const drawContainers = document.querySelectorAll('.draw-container');
  if (drawContainers.length === 0) {
    alert("No predictions available to print.");
    return;
  }
  const method = drawContainers[0]?.querySelector('.prediction-method')?.textContent.replace('Method: ', '') || 'Unknown';
  if (drawContainers.length <= 5) {
    document.body.classList.add('print-condensed');
    window.print();
    document.body.classList.remove('print-condensed');
  } else {
    const printWindow = window.open('', '_blank');
    let tableHTML = `
            <html>
            <head>
                <title>Texas Powerball Predictions using ${method}</title>
                <style>
                    body { font-family: Arial, sans-serif; }
                    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
                    th { background-color: #f2f2f2; }
                    h1 { text-align: center; }
                    footer { text-align: center; margin-top: 20px; font-size: 14px; color: #555; }
                    @media print {
                        thead { display: table-header-group; }
                    }
                </style>
            </head>
            <body>
                <h1>Texas Powerball Predictions using ${method}</h1>
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Numbers</th>
                            <th>Powerball</th>
                            <th>Method</th>
                        </tr>
                    </thead>
                    <tbody>`;
    drawContainers.forEach(container => {
      const date = container.querySelector('.draw-date').textContent;
      const balls = Array.from(container.querySelectorAll('.ball'));
      const numbers = balls.slice(0, -1).map(ball => {
        const num = parseInt(ball.textContent);
        return num < 10 ? num : ball.textContent;
      }).join(', ');
      const powerball = parseInt(balls[balls.length - 1].textContent) < 10 ? parseInt(balls[balls.length - 1].textContent) : balls[balls.length - 1].textContent;
      tableHTML += `
              <tr>
                  <td>${date}</td>
                  <td>${numbers}</td>
                  <td>${powerball}</td>
                  <td>${method}</td>
              </tr>`;
    });
    tableHTML += `
                    </tbody>
                </table>
                <footer>Created by Stephen King</footer>
            </body>
            </html>`;
    printWindow.document.write(tableHTML);
    printWindow.document.close();
    printWindow.onload = function () {
      printWindow.print();
      printWindow.close();
    };
  }
}
async function exportToEmail() {
  const drawContainers = document.querySelectorAll('.draw-container');
  if (drawContainers.length === 0) {
    alert("No predictions to export.");
    return;
  }
  const method = drawContainers[0]?.querySelector('.prediction-method')?.textContent.replace('Method: ', '') || 'Unknown';
  let content = `Texas Powerball Predictions using ${method}\n\n`;
  drawContainers.forEach(container => {
    const date = container.querySelector('.draw-date').textContent;
    const balls = Array.from(container.querySelectorAll('.ball'));
    const numbers = balls.slice(0, -1).map(ball => {
      const num = parseInt(ball.textContent);
      return num < 10 ? num : ball.textContent;
    }).join(', ');
    const powerball = parseInt(balls[balls.length - 1].textContent) < 10 ? parseInt(balls[balls.length - 1].textContent) : balls[balls.length - 1].textContent;
    content += `${date}\nNumbers: ${numbers}\nPowerball: ${powerball}\nMethod: ${method}\n\n`;
  });
  const maxUrlLength = 2000;
  let emailCount = 0;
  const emailQueue = [];
  drawContainers.forEach((container, index) => {
    const date = container.querySelector('.draw-date').textContent;
    const balls = Array.from(container.querySelectorAll('.ball'));
    const numbers = balls.slice(0, -1).map(ball => {
      const num = parseInt(ball.textContent);
      return num < 10 ? num : ball.textContent;
    }).join(', ');
    const powerball = parseInt(balls[balls.length - 1].textContent) < 10 ? parseInt(balls[balls.length - 1].textContent) : balls[balls.length - 1].textContent;
    const entry = `${date}%0D%0ANumbers: ${numbers}%0D%0APowerball: ${powerball}%0D%0AMethod: ${method}%0D%0A%0D%0A`;
    if (content.length + entry.length > maxUrlLength) {
      emailQueue.push({
        subject: `Texas Powerball Predictions using ${method} (Part ${++emailCount})`,
        body: content
      });
      content = `Texas Powerball Predictions using ${method}%0D%0A%0D%0A`;
    }
    content += entry;
    if (index === drawContainers.length - 1 && content.trim()) {
      emailQueue.push({
        subject: `Texas Powerball Predictions using ${method} (Part ${++emailCount})`,
        body: content
      });
    }
  });
  const sendEmails = () => {
    if (emailQueue.length === 0) {
      alert("All predictions have been queued for email.");
      return;
    }
    const email = emailQueue.shift();
    window.location.href = `mailto:?subject=${email.subject}&body=${email.body}`;
    setTimeout(sendEmails, 1000);
  };
  sendEmails();
}
document.addEventListener("DOMContentLoaded", async function () {
  const startDateInput = document.getElementById("startDate");
  const generateButton = document.querySelector('button[onclick="generateDraws()"]');
  generateButton.disabled = true;
  generateButton.title = 'Please load historical data first';
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, '0');
  const dd = String(today.getDate()).padStart(2, '0');
  const todayFormatted = `${yyyy}-${mm}-${dd}`;
  startDateInput.min = todayFormatted;
  const nextDrawing = getNextDrawingDate(today);
  startDateInput.value = nextDrawing.toISOString().split('T')[0];
  startDateInput.addEventListener("input", function () {
    const selectedDate = new Date(startDateInput.value);
    if (selectedDate <= today || ![1, 3, 6].includes(selectedDate.getDay())) {
      alert("Please select a Monday, Wednesday, or Saturday on or after today's date.");
      startDateInput.value = nextDrawing.toISOString().split('T')[0];
    }
  });
  generateButton.disabled = true;
  generateButton.title = 'Please load historical data first';
  // --- FIX: Enable Enter Recent Powerball Numbers immediately after successful historical load ---
  const loadBtn = document.getElementById("loadDataBtn");
  const manualBtn = document.getElementById("manualEntryBtn");
  const forceEnableManualBtnIfReady = () => {
    const ready = Array.isArray(window.historicalData) && window.historicalData.length > 0;
    if (!manualBtn) return;
    if (ready) {
      manualBtn.disabled = false;
      manualBtn.removeAttribute("disabled");
      manualBtn.style.pointerEvents = "auto";
      manualBtn.style.opacity = "1";
      manualBtn.title = "";
    } else {
      manualBtn.disabled = true;
      manualBtn.setAttribute("disabled", "");
      manualBtn.style.pointerEvents = "none";
      manualBtn.style.opacity = "0.5";
      manualBtn.title = "Please load historical data first";
    }
  };

  // initial state
  forceEnableManualBtnIfReady();

  if (loadBtn) {
    loadBtn.addEventListener("click", async (e) => {
      try {
        await loadDataFromFile();
      } finally {
        // After load completes, force-enable based on actual data readiness.
        forceEnableManualBtnIfReady();
      }
    });
  }

});



function normalizeHistoricalData(draws) {
  if (!Array.isArray(draws)) return [];
  const normDate = (d) => {
    if (!d) return null;
    // accept YYYY-MM-DD or MM/DD/YYYY or Date
    if (typeof d === 'string') {
      const s = d.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (m) {
        const mm = String(m[1]).padStart(2,'0');
        const dd = String(m[2]).padStart(2,'0');
        return `${m[3]}-${mm}-${dd}`;
      }
    }
    try {
      const dt = new Date(d);
      if (!isNaN(dt.getTime())) return dt.toISOString().slice(0,10);
    } catch {}
    return null;
  };

  const out = [];
  for (const raw of draws) {
    if (!raw) continue;
    const date = normDate(raw.date ?? raw.Date ?? raw.drawDate);
    let nums = raw.numbers ?? raw.Numbers ?? raw.main ?? raw.mainNumbers;
    if (typeof nums === 'string') {
      nums = nums.split(/[^0-9]+/).filter(Boolean).map(n=>parseInt(n,10));
    }
    if (!Array.isArray(nums)) continue;
    nums = nums.map(n=>parseInt(n,10)).filter(n=>Number.isFinite(n));
    if (nums.length !== 5) continue;
    nums = nums.map(n=>Math.min(Math.max(n,1),69));

    const specialRaw = raw.special ?? raw.powerball ?? raw.Powerball ?? raw.pb ?? raw.PB;
    const special = Math.min(Math.max(parseInt(specialRaw,10),1),26);
    if (!Number.isFinite(special)) continue;

    if (!date) continue;
    out.push({ date, numbers: nums, special });
  }

  // de-dupe by date (keep first)
  const seen = new Set();
  const dedup = [];
  for (const d of out.sort((a,b)=>a.date.localeCompare(b.date))) {
    if (seen.has(d.date)) continue;
    seen.add(d.date);
    dedup.push(d);
  }
  return dedup;
}

async function loadDataFromFile() {
  // Attempts to connect to a real file for read/write (best) using File System Access API.
  // Falls back to classic <input type="file"> read-only mode.
  const generateBtnById = document.getElementById('generateNumbersBtn');
  const generateBtnAttr = document.querySelector('button[onclick="generateDraws()"]');
  const manualEntryBtn  = document.getElementById('manualEntryBtn');
  const loadDataBtn     = document.getElementById('loadDataBtn');
  const lastDrawDateText= document.getElementById('lastDrawDateText');
  const controlsContainer = document.getElementById('controls-container');
  const loadFileBtn       = document.getElementById('load-file-btn');

  const setButtonsEnabled = (enabled) => {
    if (generateBtnById) {
      generateBtnById.disabled = !enabled;
      generateBtnById.style.opacity = enabled ? '1' : '0.5';
      generateBtnById.title = enabled ? '' : 'Please load historical data first';
    }
    if (generateBtnAttr) {
      generateBtnAttr.disabled = !enabled;
      generateBtnAttr.style.opacity = enabled ? '1' : '0.5';
      generateBtnAttr.title = enabled ? '' : 'Please load historical data first';
    }
    {
      const meBtn = document.getElementById('manualEntryBtn');
      if (meBtn) {
        meBtn.disabled = !enabled;
        meBtn.style.opacity = enabled ? '1' : '0.5';
        meBtn.title = enabled ? '' : 'Please load historical data first';
        if (enabled) meBtn.removeAttribute('disabled'); else meBtn.setAttribute('disabled','');
      }
    }
  };

  const parseHistoryFile = (content) => {
    const histMatch = content.match(/\[historicalData\](.*?)\[previousPredictions\]/s);
    const prevMatch = content.match(/\[previousPredictions\]([\s\S]*)$/);
    if (!histMatch || !prevMatch) {
      throw new Error('Invalid file format. Missing [historicalData] or [previousPredictions] sections.');
    }

    const histRaw = (histMatch[1] || '').trim();
    const prevRaw = (prevMatch[1] || '').trim();

    // ---- Parse historicalData ----
    // File format: objects separated by commas, no surrounding [ ].
    let histJson = [];
    if (histRaw) {
      if (histRaw.startsWith('[')) {
        histJson = JSON.parse(histRaw);
      } else {
        // Remove a trailing comma (common when appending)
        const cleaned = histRaw.replace(/,\s*$/,'').trim();
        histJson = JSON.parse('[' + cleaned + ']');
      }
    }

    // ---- Parse previousPredictions ----
    // Accept:
    // 1) JSON array
    // 2) NDJSON (one JSON object per line)  <-- your current standard
    // 3) legacy comma-separated objects without [ ]
    let prevJson = [];
    if (prevRaw) {
      if (prevRaw.startsWith('[')) {
        prevJson = JSON.parse(prevRaw);
      } else if (/\n\s*\{/.test(prevRaw)) {
        // NDJSON
        prevJson = prevRaw
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(l => l && l.startsWith('{') && l.endsWith('}'))
          .map(l => JSON.parse(l));
      } else {
        // Try wrap-as-array for single-object or comma-separated objects
        const cleanedPrev = prevRaw.replace(/,\s*$/,'').trim();
        try {
          prevJson = JSON.parse('[' + cleanedPrev + ']');
        } catch (e) {
          // Last resort: if it looks like `}{` without commas, split and parse
          const parts = cleanedPrev.split(/}\s*{/).map((p,i,arr)=>{
            if (i===0) return p.endsWith('}')?p:p+'}';
            if (i===arr.length-1) return p.startsWith('{')?p:'{'+p;
            return '{'+p+'}';
          });
          prevJson = parts.map(p => JSON.parse(p));
        }
      }
    }

    window.historicalData = normalizeHistoricalData(histJson);
    window.historicalData = historicalData;
    window.previousPredictions = prevJson;

    window.__pbvNext = window.__pbvNext || {};
    window.__pbvNext.historicalDataLoaded = true;

    // Immediately enable Manual Entry after successful historical data load
    try {
      const meBtn = document.getElementById('manualEntryBtn');
      if (meBtn) {
        meBtn.disabled = false;
        meBtn.removeAttribute('disabled');
        meBtn.style.opacity = '1';
        meBtn.style.pointerEvents = 'auto';
        meBtn.title = '';
      }
    } catch (e) {}

    // Update the Load button subtitle (last historical date) if UI exists
    try {
      if (histJson && histJson.length) {
        const last = histJson[histJson.length - 1];
        if (last && last.date) {
          updateLoadButtonWithLastDate(last.date);
        }
      }
    } catch (e) {}

    // Set the main Draw Date picker default to the next BLANK drawing date (Mon/Wed/Sat) that is not already in history
    try {
      const startDateInput = document.getElementById('startDate');
      if (startDateInput) {
        const nextBlank = computeNextBlankDrawDateISO();
        if (nextBlank) startDateInput.value = nextBlank;
      }
    } catch (e) {}
  };

  const updateLastDrawUI = () => {
    if (!Array.isArray(window.historicalData) || window.historicalData.length === 0) return;
    const sorted = window.historicalData.slice().sort((a, b) => new Date(b.date) - new Date(a.date));
    const mostRecent = new Date(sorted[0].date);
    mostRecent.setMinutes(mostRecent.getMinutes() + mostRecent.getTimezoneOffset());
    const formatted = mostRecent.toLocaleDateString('en-US', { year:'numeric', month:'long', day:'numeric' });

    if (loadDataBtn) {
      loadDataBtn.innerHTML = `Load Historical Data<br><small style="font-size:12px;font-weight:bold;color:green;">Last Historical Draw Date: ${formatted}</small>`;
    }
    if (lastDrawDateText) lastDrawDateText.textContent = `Last Historical Draw Date: ${formatted}`;
  };

  try {
    setButtonsEnabled(false);

    window.__pbvNext = window.__pbvNext || {};
    window.__pbvNext.loadedFileName = window.__pbvNext.loadedFileName || "Powerball_Numbers_History.txt";

    let fileContent = '';
    let connectedRW = false;

    // Prefer File System Access API for true auto-save
    if (window.showOpenFilePicker) {
      const [handle] = await window.showOpenFilePicker({
        multiple: false,
        types: [{
          description: 'Powerball History',
          accept: { 'text/plain': ['.txt'] }
        }]
      });

      if (!handle) throw new Error('No file selected');

      const file = await handle.getFile();
      fileContent = await file.text();
      window.__pbvNext.fileHandle = handle;
      window.__pbvNext.loadedFileName = file.name || window.__pbvNext.loadedFileName;

      // Attempt to get readwrite permission
      try {
        const perm = await handle.requestPermission({ mode: 'readwrite' });
        connectedRW = (perm === 'granted');
        window.__pbvNext.autoSaveSupported = true;
      } catch (e) {
        connectedRW = false;
        window.__pbvNext.autoSaveSupported = true; // API exists but permission denied
      }
    } else {
      // Fallback: classic file input (read-only)
      window.__pbvNext.autoSaveSupported = false;
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.txt';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);

      const file = await new Promise((resolve) => {
        fileInput.onchange = () => resolve(fileInput.files[0]);
        fileInput.click();
      });

      document.body.removeChild(fileInput);

      if (!file) throw new Error('No file selected');
      window.__pbvNext.loadedFileName = file.name || window.__pbvNext.loadedFileName;
      fileContent = await file.text();
      window.__pbvNext.fileHandle = null;
      connectedRW = false;
    }

    parseHistoryFile(fileContent);

    // Enable downstream controls
    setButtonsEnabled(true);

    // Ensure 'Enter Recent Powerball Numbers' is enabled immediately after successful load
    (function enableManualEntryNow(){
      const meBtn = document.getElementById('manualEntryBtn');
      if (!meBtn) return;
      meBtn.disabled = false;
      meBtn.removeAttribute('disabled');
      meBtn.style.pointerEvents = 'auto';
      meBtn.style.opacity = '1';
      meBtn.title = '';
    })();

// Show slip controls
    if (controlsContainer) controlsContainer.style.display = 'block';
    if (loadFileBtn) {
      loadFileBtn.disabled = false;
      loadFileBtn.style.cursor = 'pointer';
      loadFileBtn.style.background = 'linear-gradient(145deg, #007bff, #005bb5)';
    }

    updateLastDrawUI();
    persistToLocalStorage();

    // Update auto-save light
    updateAutoSaveLight(connectedRW);

    // Guard: enough data for LSTM?
    if (!Array.isArray(window.historicalData) || window.historicalData.length < 10) {
      alert('Historical data is missing or too small. LSTM cannot train.');
    }

    return true;

  } catch (error) {
    console.error('Error loading data:', error);
    alert(`Error loading data: ${error.message}`);
    updateAutoSaveLight(false);
    return false;
  }
}

function predictNumbersMarkov(date, drawIndex) {
  try {
    const mainTransitionMatrix = buildTransitionMatrix(historicalData.map(d => d.numbers));
    const powerballTransitionMatrix = buildTransitionMatrix(historicalData.map(d => [d.special]));
    const lastDraw = historicalData[historicalData.length - 1].numbers;
    const predictedNumbers = new Set();
    const usedStates = new Set();
    while (predictedNumbers.size < 5) {
      const currentState = lastDraw[predictedNumbers.size] || Array.from(predictedNumbers).slice(-1)[0] || Math.floor(Math.random() * 69) + 1;
      const transitions = mainTransitionMatrix.get(currentState) || new Map();
      let nextNumber = weightedRandomSelection(transitions);
      while (predictedNumbers.has(nextNumber) || usedStates.has(nextNumber)) {
        nextNumber = weightedRandomSelection(transitions);
      }
      predictedNumbers.add(nextNumber);
      usedStates.add(nextNumber);
    }
    const lastPowerball = historicalData[historicalData.length - 1].special;
    const powerballTransitions = powerballTransitionMatrix.get(lastPowerball) || new Map();
    const powerball = weightedRandomSelection(powerballTransitions) || Math.floor(Math.random() * 26) + 1;
    return {
      numbers: Array.from(predictedNumbers).sort((a, b) => a - b),
      powerball,
      method: "Markov"
    };
  } catch (error) {
    console.error('Markov prediction error:', error);
    throw error;
  }
}

function buildTransitionMatrix(sequences) {
  const matrix = new Map();
  const decayFactor = 0.95;
  sequences.forEach((sequence, seqIndex) => {
    const weight = Math.pow(decayFactor, sequences.length - seqIndex - 1);
    for (let i = 0; i < sequence.length - 1; i++) {
      const current = sequence[i];
      const next = sequence[i + 1];
      if (!matrix.has(current)) {
        matrix.set(current, new Map());
      }
      const transitions = matrix.get(current);
      transitions.set(next, (transitions.get(next) || 0) + weight);
    }
  });
  matrix.forEach(transitions => {
    const total = Array.from(transitions.values()).reduce((a, b) => a + b, 0);
    transitions.forEach((value, key) => {
      transitions.set(key, value / total);
    });
  });
  return matrix;
}

function weightedRandomSelection(transitions) {
  if (!transitions || transitions.size === 0) return null;
  const rand = Math.random();
  let cumulativeProb = 0;
  for (const [number, probability] of transitions.entries()) {
    cumulativeProb += probability;
    if (rand <= cumulativeProb) {
      return number;
    }
  }
  return Array.from(transitions.keys())[0];
}

function getMethodWeight(method) {
  const methodWeights = {
    'Exponential': 1.2,
    'Frequency': 1.0,
    'LSTM': 1.3,
    'Monte Carlo': 1.1,
    'Everything': 1.4,
    'Markov': 1.2
  };
  return methodWeights[method] || 1.0;
}

let drawingHistory = [];

function addToDrawingHistory(prediction, drawDate) {
  const validNumbers = prediction.numbers.every(n => n >= 1 && n <= 69);
  const validPowerball = prediction.powerball >= 1 && prediction.powerball <= 26;
  const uniqueNumbers = new Set(prediction.numbers).size === 5;
  if (!validNumbers || !validPowerball || !uniqueNumbers) {
    console.error('Invalid prediction numbers detected');
    return;
  }
  const isDuplicate = drawingHistory.some(entry => entry.drawDate === drawDate.toISOString() && entry.method === prediction.method);
  if (isDuplicate) {
    console.warn('Duplicate entry detected and prevented');
    return;
  }
  drawingHistory.unshift({
    method: prediction.method,
    drawDate: drawDate.toISOString(),
    numbers: [...prediction.numbers].sort((a, b) => a - b),
    powerball: prediction.powerball,
    probability: prediction.probability || calculateProbability(prediction.numbers, prediction.powerball, prediction.method)
  });
}

document.addEventListener('DOMContentLoaded', function () {
  const table = document.querySelector('.drawing-history');
  if (!table) return;
  const headers = table.querySelectorAll('th[data-sort]');
  headers.forEach(header => {
    header.addEventListener('click', () => {
      const sortKey = header.dataset.sort;
      const isAscending = header.classList.contains('sort-asc');
      headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
      header.classList.add(isAscending ? 'sort-desc' : 'sort-asc');
      sortHistory(sortKey, !isAscending);
    });
  });
});

function sortHistory(key, ascending) {
  drawingHistory.sort((a, b) => {
    let compareA = a[key];
    let compareB = b[key];
    if (key === 'date') {
      compareA = new Date(a.drawDate);
      compareB = new Date(b.drawDate);
    } else if (key === 'numbers') {
      compareA = a.numbers.join('');
      compareB = b.numbers.join('');
    }
    if (compareA < compareB) return ascending ? -1 : 1;
    if (compareA > compareB) return ascending ? 1 : -1;
    return 0;
  });
  updateHistoryTable();
}

function updateHistoryTable() {
    const tbody = document.getElementById('historyTableBody');
    if (!tbody) return;

    tbody.innerHTML = '';
    drawingHistory.sort((a, b) => new Date(a.drawDate) - new Date(b.drawDate));

    const maxProbability = Math.max(...drawingHistory.map(entry => parseFloat(entry.probability)));
    let highestProbabilityEntry = null;
    const numberFrequency = new Map();
    const powerballFrequency = new Map();

    drawingHistory.forEach(entry => {
        entry.numbers.forEach(num => {
            numberFrequency.set(num, (numberFrequency.get(num) || 0) + 1);
        });
        powerballFrequency.set(entry.powerball, (powerballFrequency.get(entry.powerball) || 0) + 1);
        if (parseFloat(entry.probability) === maxProbability) {
            highestProbabilityEntry = entry;
        }
    });

    const uniqueMethods = new Set();
    drawingHistory.forEach(entry => {
        const row = document.createElement('tr');
        const tooltipText = `5 Numbers: ${entry.numbers.join(', ')} | Powerball: ${entry.powerball}`;
        row.setAttribute('data-tooltip', tooltipText);

        if (parseFloat(entry.probability) === maxProbability) {
            row.classList.add('highest-probability');
        }

        const formattedDate = new Date(entry.drawDate).toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
        });

        const formattedNumbers = entry.numbers.map((num, index) => {
            const isDuplicate = numberFrequency.get(num) > 1;
            return `<span class="number-cell${isDuplicate ? ' duplicate-number' : ''}">${num}${index < entry.numbers.length - 1 ? ', ' : ''}</span>`;
        }).join('');

        const isPowerballDuplicate = powerballFrequency.get(entry.powerball) > 1;
        const powerballClass = isPowerballDuplicate ? 'duplicate-number' : 'powerball-number';

        row.innerHTML = `
            <td>${entry.method}</td>
            <td>${formattedDate}</td>
            <td>${formattedNumbers}</td>
            <td class="${powerballClass}">${entry.powerball}</td>
            <td>${parseFloat(entry.probability).toFixed(2)}%</td>
        `;

        uniqueMethods.add(entry.method);

        tbody.appendChild(row);
    });

    updateDuplicatesTable();
}

function updateDuplicatesTable() {
    const minGames = 3;
    const duplicatesContainer = document.querySelector('.duplicates-table-container');
    const tbody = document.getElementById('duplicatesTableBody');
    
    if (!tbody) return;

    const numberFrequency = new Map();
    const powerballMap = new Map();

    drawingHistory.forEach(({ numbers, powerball }) => {
        numbers.forEach(num => {
            numberFrequency.set(num, (numberFrequency.get(num) || 0) + 1);
        });
        powerballMap.set(powerball, (powerballMap.get(powerball) || 0) + 1);
    });

    duplicatesContainer.style.display = drawingHistory.length >= minGames ? 'block' : 'none';

    tbody.innerHTML = '';

    const topNumbers = Array.from(numberFrequency.entries())
        .sort((a, b) => b[1] - a[1] || a[0] - b[0])
        .slice(0, 5)
        .sort((a, b) => a[0] - b[0]); 

    const topPowerballs = Array.from(powerballMap.entries()).sort((a, b) => {
        if (b[1] === a[1]) { 
            const aDraw = drawingHistory.find(d => d.powerball === a[0]);
            const bDraw = drawingHistory.find(d => d.powerball === b[0]);
            return (bDraw?.probability || 0) - (aDraw?.probability || 0);
        }
        return b[1] - a[1];
    });

    const [pbNumber, pbCount] = topPowerballs[0] || [0, 0];

    const topNumbersFormatted = topNumbers.map(([num, count]) => num);
    const duplicateProbability = calculateProbability(topNumbersFormatted, pbNumber, 'Top Duplicates');

    const row = document.createElement('tr');
    const numbersFormatted = topNumbers.map(([num, count]) => 
        `<span class="duplicate-number">${num}</span> (${count})`
    ).join(', ');

    row.innerHTML = `
        <td>${numbersFormatted}</td>
        <td><span class="powerball-highlight">${pbNumber}</span> (${pbCount})</td>
        <td>${duplicateProbability}%</td>
        <td>${topNumbers.reduce((sum, [, count]) => sum + count, 0)}</td>
    `;
    tbody.appendChild(row);
}

async function hybridPrediction(drawDate, drawIndex) {
  const predictionMethods = {
    'exponential': () => ({
      ...predictNumbersExponential(drawDate, drawIndex),
      method: "Exponential"
    }),
    'frequency': () => ({
      ...predictNumbersFrequency(drawDate, drawIndex),
      method: "Frequency"
    }),
    'lstm': async () => {
      // Safety: ensure TFJS is present and model is trained (training is staged before draws)
      if (!window.tf) await ensureTFJSLoaded();
      if (!model?.isTrained) await trainModel(historicalData);
      const sequence = getHistoricalSequence(drawDate, drawIndex);
      return {
        ...(await predictNumbersLSTM(sequence, drawIndex)),
        method: "LSTM"
      };
    },
    'monteCarlo': async () => ({
      ...(await predictNumbersMonteCarlo(drawDate, drawIndex)),
      method: "Monte Carlo"
    }),
    'markov': () => ({
      ...predictNumbersMarkov(drawDate, drawIndex),
      method: "Markov"
    }),
    'everything': async () => ({
      ...(await predictNumbersEverything(drawDate, drawIndex)),
      method: "Everything"
    })
  };
  const selectedMethod = document.querySelector('input[name="predictionMethod"]:checked').value;
  try {
    return await (predictionMethods[selectedMethod] || predictionMethods.frequency)();
  } catch (error) {
    console.error(`${selectedMethod} prediction error:`, error);
    return {
      ...predictNumbersFrequency(drawDate, drawIndex),
      method: "Frequency (Fallback)"
    };
  }
}

async function trainModel(historicalData) {
  // Guard: never train twice at the same time
  window.__pbvNext = window.__pbvNext || {};
  if (window.__pbvNext.lstmTrainingPromise) return window.__pbvNext.lstmTrainingPromise;
  if (model?.isTrained) return model;

  const trainingProgressWrapper = document.getElementById('trainingProgressWrapper');
  const trainingProgress = document.getElementById('trainingProgress');
  const trainingProgressLabel = document.getElementById('trainingProgressLabel');

  const nextFrame = () => new Promise(r => requestAnimationFrame(() => r()));

  window.__pbvNext.lstmTrainingPromise = (async () => {
    trainingProgressWrapper.style.display = 'flex';
    trainingProgress.value = 0;
    trainingProgressLabel.textContent = `Training Model...0%`;
    await nextFrame();

    try {
      const sequences = [];
      const labels = [];
      const sequenceLength = 10;

      // Build training tensors (yield periodically so UI does not freeze)
      for (let i = 0; i < historicalData.length - sequenceLength; i++) {
        const sequence = [];
        for (let j = 0; j < sequenceLength; j++) {
          const draw = historicalData[i + j];
          if (!Array.isArray(draw?.numbers) || draw.numbers.length !== 5 || !Number.isFinite(draw.special)) { sequence.length = 0; break; }
          sequence.push([ ...draw.numbers, draw.special ]);
        }
        if (sequence.length !== sequenceLength) continue;
        const nextDraw = historicalData[i + sequenceLength];
        if (!Array.isArray(nextDraw?.numbers) || nextDraw.numbers.length !== 5 || !Number.isFinite(nextDraw.special)) continue;
        const label = [ ...nextDraw.numbers, nextDraw.special ];
        sequences.push(sequence);
        labels.push(label);

        if (i % 25 === 0) await nextFrame();
      }

            if (!sequences.length) {
        throw new Error('No valid training sequences after validation');
      }
const xs = tf.tensor3d(sequences);
      const ys = tf.tensor2d(labels);

      model = tf.sequential();
      model.add(tf.layers.lstm({
        units: 128,
        inputShape: [sequenceLength, 6],
        returnSequences: false
      }));
      model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
      model.add(tf.layers.dropout(0.2));
      model.add(tf.layers.dense({ units: 6 }));

      model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

      const totalEpochs = 50;

      for (let epoch = 0; epoch < totalEpochs; epoch++) {
        const progress = (epoch + 1) / totalEpochs * 100;
        trainingProgress.value = progress;
        trainingProgressLabel.textContent = `Training Model...${Math.round(progress)}%`;

        // Train a single epoch to keep UI responsive
        await model.fit(xs, ys, { epochs: 1, batchSize: 32, shuffle: true });

        // yield to allow repaint (critical)
        await nextFrame();
      }

      model.isTrained = true;
      return model;

    } catch (error) {
      console.error('Error training model:', error);
      throw error;
    } finally {
      trainingProgressWrapper.style.display = 'none';
      window.__pbvNext.lstmTrainingPromise = null;
    }
  })();

  return window.__pbvNext.lstmTrainingPromise;
}

function getHistoricalSequence(date, drawIndex) {
  const valid = (Array.isArray(historicalData) ? historicalData : []).filter(d => Array.isArray(d?.numbers) && d.numbers.length === 5 && Number.isFinite(d.special));
  const L = LSTM_SEQUENCE_LEN;
  if (valid.length >= L) return valid.slice(-L);
  return valid.slice(0);
}

window.addEventListener("message", function (event) {
    if (!event.data) return;

    const params = new URLSearchParams(event.data);
    let editedGames = [];

    for (let i = 1; i <= 5; i++) {
        let numbers = params.get(`editedGame${i}_numbers`) ? params.get(`editedGame${i}_numbers`).split(",").map(Number) : [];
        let powerball = params.get(`editedGame${i}_powerball`) ? Number(params.get(`editedGame${i}_powerball`)) : null;

        if (numbers.length === 5 && powerball) {
            editedGames.push({ numbers, powerball });
        }
    }

    if (editedGames.length > 0) {
        updateDrawDisplay(editedGames);
    }
});

function updateDrawDisplay(games) {
    const drawContainers = document.querySelectorAll("#drawsContainer .draw-container");

    games.forEach((game, index) => {
        if (drawContainers[index]) {
            drawContainers[index].querySelector(".ball-container").innerHTML =
                game.numbers.map(num => `<div class="ball">${num}</div>`).join('') +
                `<div class="ball powerball">${game.powerball}</div>`;
        }
    });

    alert("Edited numbers updated successfully!");
}

document.addEventListener('DOMContentLoaded', () => {
  // ── Grab your controls ──
  const controlsContainer    = document.getElementById('controls-container');
  const loadFileBtn          = document.getElementById('load-file-btn');
  const fileInput            = document.getElementById('pdf-upload');
  const generateSlipButton   = document.getElementById('generate-slip');
  const historyTbody         = document.getElementById('historyTableBody');
  const numGamesSelector     = document.getElementById('num-games');
  const numDrawCount	     = document.getElementById('drawCount');
  const quickPickGame4       = document.getElementById('quick-pick-game-4');
  const quickPickGame5       = document.getElementById('quick-pick-game-5');
  const duplicatesCheckbox   = document.getElementById('use-duplicates-game5');
  const useFamilyCheckbox    = document.getElementById('use-family-numbers');
  const powerPlayCheckbox    = document.getElementById('powerplay-checkbox');
  const payment30Year        = document.getElementById('payment-30year');
  const paymentCashValue     = document.getElementById('payment-cashvalue');

  let pdfFileLoaded   = false;
  let uploadedPdfBytes;

function updateHistoryForFamily() {
  // 1) remove any existing family entries
  historyTbody
    .querySelectorAll('tr.family-entry')
    .forEach(tr => tr.remove());

  // 2) bail if not checked
  if (!useFamilyCheckbox.checked) return;

  // 3) figure out the draw date from the top historical entry
  const drawingData = extractDrawingHistoryData();
  const drawDate    = drawingData[0]?.date || '';

  // 4) define your two family‐pick sets
  const familyPicks = [
    { numbers: [12, 19, 24, 48, 67], powerball: 3 },
    { numbers: [1,   3,  10, 16, 26], powerball: 7 }
  ];

  // 5) for each set, calculate its probability and build a row
  familyPicks.forEach((pick, i) => {
    const prob = calculateProbability(pick.numbers, pick.powerball, 'Family Numbers');
    const probText = `${prob.toFixed(2)}%`;

    const tr = document.createElement('tr');
    tr.classList.add('family-entry');

    const cells = {
      method:      'Family Numbers',
      date:        drawDate,
      numbers:     pick.numbers.join(', '),
      powerball:   pick.powerball.toString(),
      probability: probText
    };

    // append <td> in order
    ['method','date','numbers','powerball','probability'].forEach(key => {
      const td = document.createElement('td');
      td.textContent = cells[key];
      tr.appendChild(td);
    });

    // insert at positions 3 & 4
    historyTbody.insertBefore(tr, historyTbody.children[2 + i] || null);
  });
}



  // ── When Family#s toggles ──
  useFamilyCheckbox.addEventListener('change', () => {
    // force 2 games and lock selector
    if (useFamilyCheckbox.checked) {
      numGamesSelector.value    = '2';
      numGamesSelector.disabled = true;
    } else {
      numGamesSelector.disabled = false;
    }
    updateHistoryForFamily();
    quickPickGame4.checked    = false;
    quickPickGame4.disabled   = useFamilyCheckbox.checked;
  });

  // ── Load the PDF template ──
  loadFileBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', async () => {
    const f = fileInput.files[0];
    if (!f) return alert('Please pick a PDF.');
    uploadedPdfBytes = await f.arrayBuffer();
    pdfFileLoaded     = true;
    generateSlipButton.disabled = false;
    generateSlipButton.style.cursor = 'pointer';
    generateSlipButton.style.backgroundColor = 'green';
  });

generateSlipButton.addEventListener('click', async () => {
  if (!pdfFileLoaded) {
    alert('Please load a PDF template first.');
    return;
  }

  // 1) Make sure any “Family” rows are present
  updateHistoryForFamily();

  try {
    // 2) Pull & limit the data
    const drawingData    = extractDrawingHistoryData();
    const requestedGames = parseInt(numGamesSelector.value, 10);
    const numGames       = useFamilyCheckbox.checked ? 2 : requestedGames;

    if (drawingData.length < numGames) {
      alert(`Need at least ${numGames} historical games.`);
      return;
    }

    // 3) Pick the top-N predictions
    const sortedDrawingData = drawingData
      .slice()
      .sort((a, b) => b.probability - a.probability)
      .slice(0, numGames);

    // 4) Inject Family picks if asked
    if (useFamilyCheckbox.checked) {
      sortedDrawingData[2] = {
        numbers:   [12, 19, 24, 48, 67],
        powerball: 3,
        method:   'Family Numbers'
      };
      sortedDrawingData[3] = {
        numbers:   [1, 3, 10, 16, 26],
        powerball: 7,
        method:   'Family Numbers'
      };
    }

    // 5) Load the PDF
    const pdfDoc   = await PDFLib.PDFDocument.load(uploadedPdfBytes);
    const boldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
    const form     = pdfDoc.getForm();
    pdfDoc.getPages()[0].setSize(8.5 * 72, 3.5 * 72);

    // 6) Safe setter to avoid undefined fields
    function safeSetField(name, value) {
      const f = form.getTextField(name);
      if (!f) return console.warn(`Missing PDF field: ${name}`);
      f.setText(value);
      f.updateAppearances(boldFont);
    }

   // 7) Stamp each Game’s Model, Numbers & Powerball,
//    with the correct override precedence:
const models = sortedDrawingData.map(e => e.method || 'Unknown Model');

  // 8) Stamp Draw Date
    const drawDate = sortedDrawingData[0]?.date || 'Unknown Date';
    safeSetField('DrawDate', `Draw Date: ${drawDate}`);

// Make sure we loop through all five slots if the user asked for 5 OR if they used duplicates/QP for Game 5
const totalSlots = Math.max(sortedDrawingData.length, 5);
for (let idx = 0; idx < totalSlots; idx++) {
  const game = idx + 1;

  // pick the “method” if it exists, otherwise blank
  let modelLabel = sortedDrawingData[idx]?.method || '';

  // Game 4 Quick Pick override
  if (game === 4 && quickPickGame4.checked) {
    modelLabel = 'Quick Pick';
  }

  // Game 5 Duplicates/Quick Pick override
  if (game === 5) {
    if (duplicatesCheckbox.checked) {
      modelLabel = 'Duplicates';
    } else if (quickPickGame5.checked) {
      modelLabel = 'Quick Pick';
    }
  }

  safeSetField(`Model${game}`, modelLabel);

  // only stamp numbers if we actually have them in sortedDrawingData
  if (sortedDrawingData[idx]?.numbers) {
    sortedDrawingData[idx].numbers.forEach(n =>
      safeSetField(`Num${game}_${n}`, 'w')
    );
    safeSetField(
      `Powerball${game}_${sortedDrawingData[idx].powerball}`,
      'w'
    );
  }
}


    // 10) Quick‐Pick boxes (just the W’s in the checkboxes)
    if (quickPickGame4.checked) {
      safeSetField('Quick4_1', 'w');
      safeSetField('Quick4_2', 'w');
    }
    if (quickPickGame5.checked) {
      safeSetField('Quick5_1', 'w');
      safeSetField('Quick5_2', 'w');
    }

    // 11) PowerPlay & Payment options
    safeSetField('PowerPlay', powerPlayCheckbox.checked ? 'w' : '');
    safeSetField('Cash_2',    payment30Year.checked   ? 'w' : '');
    safeSetField('Cash_1',      paymentCashValue.checked? 'w' : '');

    // 12) Multi‐box logic
    const multiOptions = [2,3,4,5,6,7,8,9,10,12,15];
    multiOptions.forEach(n => safeSetField(`Multi_${n}`, ''));
    const sel = parseInt(numDrawCount.value, 10);
    if (multiOptions.includes(sel)) {
      safeSetField(`Multi_${sel}`, 'w');
    }

    // 13) Save & download
    const pdfBytes = await pdfDoc.save();
    const blob     = new Blob([pdfBytes], { type: 'application/pdf' });
    const link     = document.createElement('a');
    link.href      = URL.createObjectURL(blob);
    link.download  = `powerballslip_${new Date()
                            .toISOString()
                            .slice(0,10)}.pdf`;
    link.click();
    alert(`PDF generated: ${link.download}`);
  } catch (err) {
    console.error(err);
    alert(`Error generating PDF: ${err.message}`);
  }
});

    function extractDrawingHistoryData() {
        return [...document.querySelectorAll('#historyTableBody tr')].map(row => ({
            method: row.cells[0]?.textContent.trim() || null,
            date: row.cells[1]?.textContent.trim() || null,
            numbers: row.cells[2]?.textContent.split(',').map(num => parseInt(num.trim(), 10)) || [],
            powerball: parseInt(row.cells[3]?.textContent.trim(), 10) || null,
            probability: parseFloat(row.cells[4]?.textContent.trim().replace('%', '')) || null
        }));
    }
});

document.addEventListener('DOMContentLoaded', function () {
   window.__pbvNext = window.__pbvNext || {};
   window.__pbvNext.historicalDataLoaded = false;

    const generateNumbersBtn = document.getElementById("generateNumbersBtn");
    const manualEntryBtn      = document.getElementById("manualEntryBtn");
    const bypassCheckbox      = document.getElementById("bypassHistoricalData");

    function findMostRecentDrawDate() {
        if (!window.historicalData || window.historicalData.length === 0) return null;

        const sortedData = window.historicalData.sort((a, b) => new Date(b.date) - new Date(a.date));
        return new Date(sortedData[0].date).toLocaleDateString("en-US", {
            year: 'numeric', month: 'long', day: 'numeric'
        });
    }

    function updateGenerateButtonState() {
        const allowActions = bypassCheckbox.checked || window.__pbvNext.historicalDataLoaded;

        // Generate numbers
        generateNumbersBtn.disabled = !allowActions;
        generateNumbersBtn.style.opacity = allowActions ? "1" : "0.5";
        generateNumbersBtn.title = allowActions ? "" : "Please load historical data first";

        // Manual entry (recent winning numbers)
// NOTE: Use actual parsed historical data readiness (not a separate flag) so the button becomes clickable immediately after a successful load.
const histReady = Array.isArray(window.historicalData) && window.historicalData.length > 0;
manualEntryBtn.disabled = !histReady;
manualEntryBtn.style.opacity = histReady ? "1" : "0.5";
manualEntryBtn.title = histReady ? "" : "Please load historical data first";

        // Ensure the HTML disabled attribute matches state (some browsers/styles rely on it)
        if (manualEntryBtn.disabled) {
            manualEntryBtn.setAttribute("disabled", "");
        } else {
            manualEntryBtn.removeAttribute("disabled");
        }
    }


   
 });



function showManualEntryForm() {
    const container = document.getElementById('numberEntry');
    container.innerHTML = '';

    // Check if historical data is loaded
    if (!window.historicalData || window.historicalData.length === 0) {
        alert("Please load historical data first.");
        return;
    }

    // Build a set of existing draw dates in YYYY-MM-DD
    const historyDateSet = new Set(window.historicalData.map(r => r.date));

    // Find last historical date (most recent)
    const lastHistoricalDate = new Date(
        window.historicalData
            .slice()
            .sort((a, b) => new Date(b.date) - new Date(a.date))[0].date
    );

    // Determine the next scheduled draw date after TODAY (so user can enter the next draw even if it's in the future)
    const today = new Date();
    const nextAfterToday = getNextDrawingDate(today);

    // Build candidate dates from (lastHistoricalDate + 1 day) up through nextAfterToday
    const options = [];
    let cursor = new Date(lastHistoricalDate);
    cursor.setHours(12,0,0,0); // normalize midday to avoid DST edge cases
    const end = new Date(nextAfterToday);
    end.setHours(12,0,0,0);

    // Safety cap: don't loop forever
    let guard = 0;
    while (cursor.getTime() <= end.getTime() && guard < 400) {
        guard++;
        cursor.setDate(cursor.getDate() + 1);

        const day = cursor.getDay(); // 1=Mon,3=Wed,6=Sat
        if (![1,3,6].includes(day)) continue;

        const dateStr = cursor.toISOString().split('T')[0];
        if (!historyDateSet.has(dateStr)) {
            options.push(new Date(cursor));
        }
    }

    // If there are no missing/blank draw dates up through the next scheduled draw, disable entry
    if (options.length === 0) {
        document.getElementById('manualEntryBtn').disabled = true;
        alert("All drawings up through the next scheduled draw already have historical data.");
        return;
    }

    // Limit dropdown to the 20 earliest missing/blank draw dates
    const first20 = options.slice(0, 20);

    // Add date selector (default = next blank draw date, which is the first option)
    container.innerHTML += `
        <label for="drawDate">Select Drawing Date:</label>
        <select id="drawDate" required style="margin-bottom: 20px; font-size: 16px; padding: 5px;">
            ${first20.map(date => `
                <option value="${date.toISOString().split('T')[0]}">${formatDate(date)}</option>
            `).join('')}
        </select><br><br>
    `;
    const ddSel = document.getElementById('drawDate');
    if (ddSel && ddSel.options.length) { ddSel.selectedIndex = 0; ddSel.value = ddSel.options[0].value; }

    // Create a wrapper for number inputs
    const inputWrapper = document.createElement('div');
    inputWrapper.style.display = 'flex';
    inputWrapper.style.gap = '15px';
    inputWrapper.style.marginBottom = '20px';
    inputWrapper.style.flexWrap = 'wrap';
    inputWrapper.style.justifyContent = 'center';

    // Styling function for spherical inputs
    function styleBall(input, bgColor, textColor, borderColor, shadowColor) {
        input.style.width = '78px';
        input.style.height = '78px';
        input.style.borderRadius = '50%';
        input.style.border = `2px solid ${borderColor}`;
        input.style.background = `radial-gradient(circle at top left, #ffffff, ${bgColor})`;
        input.style.color = textColor;
        input.style.fontSize = '20px';
        input.style.fontWeight = 'bold';
        input.style.textAlign = 'center';
        input.style.boxShadow = `0 4px 10px ${shadowColor}`;
        input.style.outline = 'none';
        input.style.transition = 'transform 0.2s ease';
        input.addEventListener('focus', () => input.style.transform = 'scale(1.1)');
        input.addEventListener('blur', () => input.style.transform = 'scale(1.0)');
    }

    // Add 5 regular ball inputs
    for (let i = 0; i < 5; i++) {
        const ballInput = document.createElement('input');
        ballInput.type = 'number';
        ballInput.min = 1;
        ballInput.max = 69;
        ballInput.className = 'number-input main-number-input';
        ballInput.placeholder = '0';
        styleBall(ballInput, '#4facfe', '#ffffff', '#00f2fe', 'rgba(0, 242, 254, 0.5)');
        // Prevent duplicate main numbers at entry time
        ballInput.addEventListener('input', () => {
            const v = parseInt(ballInput.value, 10);
            if (Number.isNaN(v)) return;
            // Range guard (browser should enforce, but keep clean)
            if (v < 1 || v > 69) { ballInput.value=''; return; }
            const mains = Array.from(document.querySelectorAll('.main-number-input'))
              .map(el => parseInt(el.value, 10))
              .filter(n => !Number.isNaN(n));
            const seen = new Set();
            let dup = false;
            for (const n of mains) { if (seen.has(n)) { dup = true; break; } seen.add(n); }
            if (dup) {
                ballInput.value = '';
                if (typeof showPopup === 'function') showPopup('⚠️ Duplicate main number not allowed. Please choose a different number.');
                else alert('Duplicate main number not allowed. Please choose a different number.');
            }
        });
        inputWrapper.appendChild(ballInput);
    }

    // Add Powerball input
    const powerballInput = document.createElement('input');
    powerballInput.type = 'number';
    powerballInput.min = 1;
    powerballInput.max = 24;
    // Use number-input too so it inherits the same spinner-removal + base styling rules
    powerballInput.className = 'number-input powerball-input';
    powerballInput.id = 'powerballInput';
    // PB ball same size as other balls
    powerballInput.style.width = '78px';
    powerballInput.style.height = '78px';

    powerballInput.placeholder = 'PB';
    powerballInput.addEventListener('input', () => {
        const v = parseInt(powerballInput.value, 10);
        if (isNaN(v)) return;
        if (v < 1 || v > 24) {
            powerballInput.value = '';
            if (typeof showPopup === 'function') showPopup('PowerBall must be between 1 and 24.');
            else alert('PowerBall must be between 1 and 24.');
        }
    });

    styleBall(powerballInput, '#ff416c', '#ffffff', '#ff7c9e', '#ff416c');
    inputWrapper.appendChild(powerballInput);

    
    // Auto-advance focus when 2 digits entered
    const allInputs = Array.from(inputWrapper.querySelectorAll('input'));
    allInputs.forEach((inp, idx) => {
        inp.setAttribute('inputmode', 'numeric');
        inp.addEventListener('input', () => {
            const v = String(inp.value || '');
            // if user typed 2 digits (or hit max length), move to next input
            if (v.length >= 2 && idx < allInputs.length - 1) {
                allInputs[idx + 1].focus();
                allInputs[idx + 1].select?.();
            }
        });
    });
container.appendChild(inputWrapper);
    document.getElementById('manualEntryModal').style.display = 'block';
}

function hideManualEntryForm() {
    document.getElementById('manualEntryModal').style.display = 'none';

    // If we successfully saved winning numbers during this modal session, reload the historical file and refresh
    if (window.__pbvNext && window.__pbvNext.manualEntrySaved === true) {
        // Reset flag so this only triggers once
        window.__pbvNext.manualEntrySaved = false;
        reloadHistoricalDataAndRefresh();
    }
}

async 
async function submitManualEntry() {
    const numberInputs = Array.from(document.querySelectorAll('.main-number-input'));
    const powerballInput = document.getElementById('powerballInput');
    const dateInput = document.getElementById('drawDate');
    const submitBtn = document.getElementById('submitNumbersBtn');

    // Basic validation
    if (!dateInput || !dateInput.value) {
        alert('Please select the draw date.');
        return;
    }

    const numbers = numberInputs.map(input => parseInt(input.value, 10));
    const powerball = parseInt(powerballInput.value, 10);

    if (numbers.some(n => Number.isNaN(n)) || Number.isNaN(powerball)) {
        alert('Please enter all numbers (5 mains + 1 Powerball).');
        return;
    }

    
    // No duplicate entries allowed for the 5 main number balls
    const uniq = new Set(numbers);
    if (uniq.size !== numbers.length) { alert('Duplicate main numbers are not allowed. Please enter 5 unique numbers.'); return; }
// Range checks
    for (const n of numbers) {
        if (n < 1 || n > 69) { alert('Main numbers must be between 1 and 69.'); return; }
    }
    // Powerball range is 1–26
    if (powerball < 1 || powerball > 24) { alert('Powerball must be between 1 and 24.'); return; }

    // Uniqueness for main numbers
    const uniqueMain = new Set(numbers);
    if (uniqueMain.size !== numbers.length) {
        alert('Main numbers must be unique.');
        return;
    }

    // Normalize date to UTC midnight string used elsewhere
    const rawDate = dateInput.value;
    const dateObj = new Date(rawDate + 'T00:00:00');
    const utcDate = new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000);
    const formattedDate = utcDate.toISOString().split('T')[0];

    // Prevent duplicates (same date)
    if (Array.isArray(window.historicalData) && window.historicalData.some(d => d.date === formattedDate)) {
        alert('That draw date already exists in historical data. Please choose the next blank draw date.');
        return;
    }

    // Insert into historicalData (append then sort)
    const newEntry = { date: formattedDate, numbers: numbers.join(', '), powerball: String(powerball) };
    window.historicalData = Array.isArray(window.historicalData) ? window.historicalData : [];
    window.historicalData.push(newEntry);
    window.historicalData.sort((a,b) => new Date(a.date) - new Date(b.date));

    // Rebuild full file content in the same format (historical first, then previous predictions)
    const fileContent = buildHistoryTxt();

    // UX: disable while saving
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Saving...';
    }

    let saved = false;

    // Try true auto-save (File System Access API + read/write permission)
    try {
        const handle = window.__pbvNext && window.__pbvNext.fileHandle;
        if (handle && handle.createWritable) {
            // Ensure permission (some browsers may require asking again)
            let perm = 'granted';
            if (handle.requestPermission) {
                perm = await handle.requestPermission({ mode: 'readwrite' });
            }
            if (perm === 'granted') {
                const writable = await handle.createWritable();
                await writable.write(fileContent);
                await writable.close();
                saved = true;
                updateAutoSaveLight(true);
                showPopup(`✅ Saved automatically to ${window.__pbvNext.loadedFileName}`);
            } else {
                updateAutoSaveLight(false);
            }
        }
    } catch (e) {
        console.warn('Auto-save failed, will fall back to download:', e);
        updateAutoSaveLight(false);
        saved = false;
    }

    // Fallback: download a new file (browser limitation)
    if (!saved) {
        showPopup('⚠️ Auto-save not available. Downloading updated file instead.');
        downloadTextFile(fileContent, window.__pbvNext?.loadedFileName || "Powerball_Numbers_History(updated).txt");
    }

    // Refresh UI from the updated in-memory data
    persistToLocalStorage();
    if (typeof updateWinningDateSelectorToNextBlank === 'function') { updateWinningDateSelectorToNextBlank(); }
    updateLoadButtonWithLastDrawDate();
    displayMostRecentDraw();
    updateGenerateButtonState();

    if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Winning Numbers';
    }

    // Mark that we saved during this modal session (used by Cancel behavior)
    window.__pbvNext = window.__pbvNext || {};
    window.__pbvNext.manualEntrySaved = true;

    // Tell the user what happened, then (after they acknowledge) clear inputs and advance date
    if (saved) {
        await showAckPopup('✅ Winning numbers saved successfully.', { title: 'Saved', buttonText: 'OK' });

        // Clear inputs
        numberInputs.forEach(i => i.value = '');
        if (powerballInput) powerballInput.value = '';

        // Advance to the next blank scheduled draw date (Mon/Wed/Sat) not in history
        try {
            const usedDate = dateInput.value;

            // Remove the used option from the dropdown to prevent duplicates
            if (dateInput && usedDate) {
                const optToRemove = Array.from(dateInput.options).find(o => o.value === usedDate);
                if (optToRemove) optToRemove.remove();
            }

            if (dateInput && dateInput.options.length > 0) {
                dateInput.selectedIndex = 0;
                dateInput.value = dateInput.options[0].value;
            } else {
                // No more blank dates available through next scheduled draw
                hideManualEntryForm();
                const meBtn = document.getElementById('manualEntryBtn');
                if (meBtn) { meBtn.disabled = true; meBtn.setAttribute('disabled',''); meBtn.style.opacity = '0.5'; }
            }
        } catch (e) {
            console.warn('Could not advance draw date selector:', e);
        }
    } else {
        // Not successful — tell user to retry
        await showAckPopup('❌ Could not save winning numbers. Please retry.', { title: 'Save Failed', buttonText: 'OK' });
        window.__pbvNext.manualEntrySaved = false;
        return;
    }
}
function triggerReloadUpdatedFile() {
    const reloadInput = document.createElement('input');
    reloadInput.type = 'file';
    reloadInput.accept = '.txt';
    reloadInput.style.display = 'none';

    reloadInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            loadManualDataDirectly(text);
            showSuccessPopup('Updated file reloaded successfully!');
        };
        reader.readAsText(file);
    });

    document.body.appendChild(reloadInput);
    reloadInput.click();
}
function loadManualDataDirectly(fileText) {
    try {
        const historicalDataSection = fileText.match(/\[historicalData\](.*?)\[previousPredictions\]/s);
        const previousPredictionsSection = fileText.match(/\[previousPredictions\](.*)$/s);

        if (!historicalDataSection || !previousPredictionsSection) {
            console.error('Invalid file format.');
            return;
        }

        window.historicalData = JSON.parse(`[${historicalDataSection[1].trim()}]`);
        window.previousPredictions = JSON.parse(`[${previousPredictionsSection[1].trim()}]`);

        console.log('Reloaded historical data:', window.historicalData.length, 'draws.');
    } catch (error) {
        console.error('Error parsing updated file:', error);
    }
}

function showSuccessPopup(message) {
    const popup = document.createElement('div');
    popup.textContent = message;
    popup.style.position = 'fixed';
    popup.style.top = '50%';
    popup.style.left = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.background = 'linear-gradient(145deg, #2ecc71, #27ae60)';
    popup.style.color = 'white';
    popup.style.padding = '20px 40px';
    popup.style.fontSize = '20px';
    popup.style.borderRadius = '15px';
    popup.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    popup.style.opacity = '0';
    popup.style.zIndex = '10000';
    popup.style.transition = 'opacity 0.5s ease, transform 0.5s ease';

    document.body.appendChild(popup);

    setTimeout(() => {
        popup.style.opacity = '1';
        popup.style.transform = 'translate(-50%, -50%) scale(1.05)';
    }, 10);

    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translate(-50%, -50%) scale(0.95)';
    }, 2500);

    setTimeout(() => {
        document.body.removeChild(popup);
    }, 3000);
}


function showAckPopup(message, opts = {}) {
    const title = opts.title || '';
    const buttonText = opts.buttonText || 'OK';
    return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.background = 'rgba(0,0,0,0.55)';
        overlay.style.zIndex = '20000';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.padding = '20px';

        const box = document.createElement('div');
        box.style.background = '#111';
        box.style.color = '#fff';
        box.style.maxWidth = '520px';
        box.style.width = '100%';
        box.style.borderRadius = '16px';
        box.style.boxShadow = '0 10px 30px rgba(0,0,0,0.35)';
        box.style.padding = '18px 18px 14px 18px';
        box.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

        if (title) {
            const h = document.createElement('div');
            h.textContent = title;
            h.style.fontSize = '18px';
            h.style.fontWeight = '700';
            h.style.marginBottom = '10px';
            box.appendChild(h);
        }

        const body = document.createElement('div');
        body.textContent = message;
        body.style.fontSize = '15px';
        body.style.lineHeight = '1.35';
        body.style.marginBottom = '14px';
        box.appendChild(body);

        const btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.justifyContent = 'flex-end';
        btnRow.style.gap = '10px';

        const ok = document.createElement('button');
        ok.textContent = buttonText;
        ok.style.background = 'linear-gradient(145deg, #2ecc71, #27ae60)';
        ok.style.color = '#fff';
        ok.style.border = 'none';
        ok.style.borderRadius = '999px';
        ok.style.padding = '10px 18px';
        ok.style.cursor = 'pointer';
        ok.style.fontSize = '14px';
        ok.style.fontWeight = '700';

        ok.addEventListener('click', () => {
            try { document.body.removeChild(overlay); } catch {}
            resolve(true);
        });

        btnRow.appendChild(ok);
        box.appendChild(btnRow);
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        ok.focus();
    });
}

async function reloadHistoricalDataAndRefresh() {
    try {
        // Prefer re-reading the same file handle if available
        const handle = window.__pbvNext && window.__pbvNext.fileHandle;
        if (handle) {
            const file = await handle.getFile();
            const text = await file.text();
            if (typeof parseHistoryFile === 'function') {
                parseHistoryFile(text);
            } else if (typeof loadManualDataDirectly === 'function') {
                loadManualDataDirectly(text);
            }
            if (typeof persistToLocalStorage === 'function') persistToLocalStorage();
            location.reload();
            return;
        }
    } catch (e) {
        console.warn('Reload from file handle failed:', e);
    }

    // Fallback: prompt user to select the updated file, then refresh
    if (typeof triggerReloadUpdatedFile === 'function') {
        const original = window.showSuccessPopup;
        // triggerReloadUpdatedFile already shows success popup; we refresh after a short delay
        triggerReloadUpdatedFile();
        setTimeout(() => { try { location.reload(); } catch {} }, 800);
        return;
    }
}


/* ===== vNext Final Integration Patch (2025-12-24) =====
   - Fix manual entry (in-memory + localStorage + downloadable file)
   - Add missing exportToFile()
   - Lazy-load TensorFlow.js only when LSTM is used
*/

window.__pbvNext = window.__pbvNext || {};
window.__pbvNext.loadedFileName = window.__pbvNext.loadedFileName || "Powerball Numbers (updated).txt";

function ensureTFJSLoaded() {
  return new Promise((resolve, reject) => {
    if (window.tf) return resolve();
    const existing = document.querySelector('script[data-tfjs="1"]');
    if (existing) { existing.addEventListener('load', resolve); existing.addEventListener('error', reject); return; }
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs';
    s.defer = true;
    s.dataset.tfjs = "1";
    s.onload = () => resolve();
    s.onerror = () => reject(new Error('Failed to load TensorFlow.js'));
    document.head.appendChild(s);
  });
}

function buildHistoryTxt() {
  const hist = Array.isArray(window.historicalData) ? window.historicalData : [];
  const prev = Array.isArray(window.previousPredictions) ? window.previousPredictions : [];
  const histJson = JSON.stringify(hist, null, 2);
  const prevLines = prev.map(r => JSON.stringify(r)).join("\n");
  return `[historicalData]\n\n${histJson.slice(1, -1)}\n\n[previousPredictions]\n${prevLines}\n`;
}

function downloadTextFile(filename, content) {
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); document.body.removeChild(a); }, 0);
}

function persistToLocalStorage() {
  try {
    localStorage.setItem('pb_historicalData', JSON.stringify(window.historicalData || []));
    localStorage.setItem('pb_previousPredictions', JSON.stringify(window.previousPredictions || []));
    localStorage.setItem('pb_loadedFileName', window.__pbvNext.loadedFileName || "Powerball Numbers (updated).txt");
  } catch (e) {}
}


function updateAutoSaveLight(isConnectedReadWrite) {
  const light = document.getElementById('autoSaveLight');
  if (!light) return;

  // states:
  // - green: connected read/write and auto-save will work
  // - yellow: File System Access API exists but not granted read/write
  // - red: classic file upload (read-only) or not connected
  const apiAvailable = !!window.showOpenFilePicker;

  let color = '#cc0000';
  let title = 'Auto-save not connected (read-only)';

  if (apiAvailable && window.__pbvNext && window.__pbvNext.fileHandle) {
    if (isConnectedReadWrite) {
      color = '#2ecc71';
      title = 'Auto-save connected (read/write)';
    } else {
      color = '#f1c40f';
      title = 'Auto-save available but permission not granted (read-only)';
    }
  } else if (!apiAvailable) {
    color = '#cc0000';
    title = 'Auto-save not supported by this browser (read-only)';
  }

  light.style.background = color;
  light.title = title;
}


function hydrateFromLocalStorage() {
  try {
    const h = localStorage.getItem('pb_historicalData');
    const p = localStorage.getItem('pb_previousPredictions');
    const n = localStorage.getItem('pb_loadedFileName');
    if (h && !window.historicalData) window.historicalData = JSON.parse(h);
    if (p && !window.previousPredictions) window.previousPredictions = JSON.parse(p);
    if (n) window.__pbvNext.loadedFileName = n;
  } catch (e) {}
}
hydrateFromLocalStorage();

window.exportToFile = function exportToFile() {
  if (!Array.isArray(window.historicalData) || window.historicalData.length === 0) {
    alert('No historical data loaded yet. Click "Load Historical Data" first.');
    return;
  }
  const content = buildHistoryTxt();
  persistToLocalStorage();
  downloadTextFile(window.__pbvNext.loadedFileName, content);
  showSuccessPopup('Saved updated history file.');
};

// Override manual-entry submit to NOT require a second file-picker
window.submitManualEntry = function submitManualEntry() {
  const numberInputs = Array.from(document.querySelectorAll('.main-number-input'));
  const powerballInput = document.querySelector('.powerball-input');
  const drawDateInput = document.getElementById('drawDate');

  if (!Array.isArray(window.historicalData) || window.historicalData.length === 0) {
    alert('Load your history file first using "Load Historical Data".');
    return;
  }

  const numbers = numberInputs.map(i => parseInt(i.value, 10)).filter(n => !Number.isNaN(n));
  const powerball = parseInt(powerballInput?.value, 10);
  const rawDate = (drawDateInput?.value || '').trim();
  const parsedDate = rawDate ? new Date(rawDate) : null;
  const drawDate = parsedDate && !isNaN(parsedDate.getTime())
    ? parsedDate.getFullYear() + '-' + String(parsedDate.getMonth() + 1).padStart(2,'0') + '-' + String(parsedDate.getDate()).padStart(2,'0')
    : '';

  // Validation (exactly 5 mains, unique, range, PB range)
  if (numbers.length !== 5 ||
      numbers.some(n => n < 1 || n > 69) ||
      (new Set(numbers)).size !== 5 ||
      Number.isNaN(powerball) || powerball < 1 || powerball > 24 ||
      !drawDate) {
    alert('Enter 5 unique main numbers (1–69), 1 Powerball (1–26), and a valid drawing date.');
    return;
  }

  const normalized = [...numbers].sort((a,b)=>a-b);
  const existingIdx = window.historicalData.findIndex(r => r.date === drawDate);
  const record = { date: drawDate, numbers: normalized, special: powerball };

  if (existingIdx >= 0) {
    window.historicalData[existingIdx] = record;
  } else {
    window.historicalData.push(record);
  }

  // keep sorted by date
  window.historicalData.sort((a,b)=> (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));

  // Update UI table if present
  try {
    if (typeof updateDrawingHistoryTable === 'function') updateDrawingHistoryTable();
  } catch (e) {}

  persistToLocalStorage();
  hideManualEntryForm();
  showSuccessPopup(existingIdx>=0 ? 'Drawing updated. Use "Save to File".' : 'Drawing added. Use "Save to File".');
};

// If user selects LSTM, ensure tfjs is ready before running heavy ops
document.addEventListener('change', async (e) => {
  const t = e.target;
  if (t && t.name === 'predictionMethod' && t.value === 'lstm' && t.checked) {
    try { await ensureTFJSLoaded(); showSuccessPopup('LSTM engine ready.'); } catch(err) { alert(err.message); }
  }
});
/* ===== End Patch ===== */
</script>
</body></html>
